// Generated by dts-bundle v0.7.3

declare module 'doric' {
    export * from 'doric/lib/src/runtime/global';
    export * from 'doric/lib/src/ui/index.ui';
    export * from "doric/lib/src/widget/index.widget";
    export * from 'doric/lib/src/native/index.native';
    export * from "doric/lib/src/util/index.util";
    export * from "doric/lib/src/pattern/index.pattern";
}

declare module 'doric/lib/src/runtime/global' {
    import { Panel } from "doric/lib/src/ui/panel";
    import { ClassType } from "doric/lib/src/util/types";
    export type BridgeContext = {
            /**
                * The identify of current context
                */
            id: string;
            /**
                * In this case,It's current panel
                */
            entity: any;
            /**
                * call native plugin
                * @param namespace
                * @param method
                * @param args
                */
            callNative(namespace: string, method: string, args?: any): Promise<any>;
            /**
                * Transform function to functionId as string
                * @param func
                */
            function2Id(func: Function): string;
            /**
                * Remove transformed functions
                * @param funcId
                */
            removeFuncById(funcId: string): void;
    };
    global {
            const context: BridgeContext;
            const Environment: {
                    platform: "Android" | "iOS" | "Qt" | "web";
                    platformVersion: string;
                    appName: string;
                    appVersion: string;
                    libVersion: string;
                    screenWidth: number;
                    screenHeight: number;
                    screenScale: number;
                    statusBarHeight: number;
                    hasNotch: boolean;
                    /**
                        * ex:Apple or Google
                        */
                    deviceBrand: string;
                    /**
                        * ex: iPhone12,5 or pixel 3
                        */
                    deviceModel: string;
                    /**
                        * The language code for current locale
                        */
                    localeLanguage: string;
                    /**
                        * The country/region code for current locale
                        */
                    localeCountry: string;
                    [index: string]: number | string | boolean | object | undefined;
            };
            function Entry(constructor: ClassType<Panel>): void;
            function Entry(exports: ClassType<Panel>[]): (constructor: ClassType<Panel>) => void;
    }
    export {};
}

declare module 'doric/lib/src/ui/index.ui' {
    export * from 'doric/lib/src/ui/view';
    export * from 'doric/lib/src/ui/panel';
    export * from 'doric/lib/src/ui/animation';
}

declare module 'doric/lib/src/widget/index.widget' {
    export * from 'doric/lib/src/widget/layouts';
    export * from 'doric/lib/src/widget/text';
    export * from 'doric/lib/src/widget/image';
    export * from 'doric/lib/src/widget/list';
    export * from 'doric/lib/src/widget/slider';
    export * from 'doric/lib/src/widget/scroller';
    export * from 'doric/lib/src/widget/refreshable';
    export * from 'doric/lib/src/widget/flowlayout';
    export * from 'doric/lib/src/widget/input';
    export * from 'doric/lib/src/widget/nestedSlider';
    export * from 'doric/lib/src/widget/draggable';
    export * from 'doric/lib/src/widget/switch';
    export * from 'doric/lib/src/widget/gesture';
    export * from 'doric/lib/src/widget/effect';
}

declare module 'doric/lib/src/native/index.native' {
    export * from 'doric/lib/src/native/modal';
    export * from 'doric/lib/src/native/navbar';
    export * from 'doric/lib/src/native/navigator';
    export * from 'doric/lib/src/native/network';
    export * from 'doric/lib/src/native/storage';
    export * from 'doric/lib/src/native/popover';
    export * from 'doric/lib/src/native/animate';
    export * from 'doric/lib/src/native/notification';
    export * from 'doric/lib/src/native/statusbar';
    export * from 'doric/lib/src/native/coordinator';
    export * from 'doric/lib/src/native/notch';
    export * from 'doric/lib/src/native/keyboard';
    export * from 'doric/lib/src/native/resourceLoader';
    export * from 'doric/lib/src/native/imageDecoder';
}

declare module 'doric/lib/src/util/index.util' {
    export * from 'doric/lib/src/util/color';
    export * from 'doric/lib/src/util/gravity';
    export * from 'doric/lib/src/util/layoutconfig';
    export * from 'doric/lib/src/util/log';
    export * from 'doric/lib/src/util/types';
    export * from 'doric/lib/src/util/uniqueId';
    export * from 'doric/lib/src/util/flexbox';
    export * from 'doric/lib/src/util/jsx';
    export * from 'doric/lib/src/util/resource';
}

declare module 'doric/lib/src/pattern/index.pattern' {
    export * from 'doric/lib/src/pattern/candies';
    export * from 'doric/lib/src/pattern/provider';
    export * from 'doric/lib/src/pattern/mvvm';
    export * from 'doric/lib/src/pattern/modular';
}

declare module 'doric/lib/src/ui/panel' {
    import { View, Group } from "doric/lib/src/ui/view";
    import { Root } from 'doric/lib/src/widget/layouts';
    import { BridgeContext } from 'doric/lib/src/runtime/global';
    export function NativeCall(target: Panel, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor;
    export abstract class Panel {
        context: BridgeContext;
        onCreate(): void;
        onDestroy(): void;
        onShow(): void;
        onHidden(): void;
        onEnvChanged(): void;
        /**
          * Build view of the current Panel
          * This could be called any times at any time when necessary.
          * @param rootView root view of this panel
          */
        abstract build(rootView: Group): void;
        addHeadView(type: string, v: View): void;
        allHeadViews(): IterableIterator<Map<string, View>>;
        removeHeadView(type: string, v: View | string): void;
        clearHeadViews(type: string): void;
        getRootView(): Root;
        getInitData(): object | undefined;
        onRenderFinished(): void;
        addOnRenderFinishedCallback(cb: () => void): void;
    }
}

declare module 'doric/lib/src/util/types' {
    export interface Modeling {
        toModel(): Model;
    }
    export function obj2Model(obj: Model, convertor: (v: Function) => string): Model;
    type _M = string | number | boolean | Modeling | {
        [index: string]: Model;
    } | undefined;
    export type Model = _M | Array<_M>;
    export type Binder<T> = (v: T) => void;
    export class Mutable<T> {
        get: () => T;
        set: (v: T) => void;
        bind(binder: Binder<T>): void;
        static of<E>(v: E): Mutable<E>;
    }
    export type ClassType<T> = new (...args: any) => T;
    export {};
}

declare module 'doric/lib/src/ui/view' {
    import { Color, GradientColor } from "doric/lib/src/util/color";
    import { Modeling, Model, ClassType } from "doric/lib/src/util/types";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { LayoutConfig } from 'doric/lib/src/util/layoutconfig';
    import { IAnimation } from "doric/lib/src/ui/animation";
    import { FlexConfig } from "doric/lib/src/util/flexbox";
    export function Property(target: Object, propKey: string): void;
    export function InconsistProperty(target: Object, propKey: string): void;
    export function ViewComponent(constructor: ClassType<any>): void;
    export type NativeViewModel = {
            id: string;
            type: string;
            props: {
                    [index: string]: Model;
            };
    };
    type RefType<T> = T extends Ref<infer R> ? R : never;
    export class Ref<T extends View> {
            set current(v: T);
            get current(): T;
            apply(config: Partial<RefType<this>>): void;
    }
    export function createRef<T extends View>(): Ref<T>;
    export abstract class View implements Modeling {
            width: number;
            height: number;
            x: number;
            y: number;
            backgroundColor?: Color | GradientColor;
            corners?: number | {
                    leftTop?: number;
                    rightTop?: number;
                    leftBottom?: number;
                    rightBottom?: number;
            };
            border?: {
                    width: number;
                    color: Color;
            };
            shadow?: {
                    color: Color;
                    opacity: number;
                    radius: number;
                    offsetX: number;
                    offsetY: number;
            };
            /**
                * float [0,..1]
                */
            alpha?: number;
            hidden?: boolean;
            viewId: string;
            tag?: string;
            padding?: {
                    left?: number;
                    right?: number;
                    top?: number;
                    bottom?: number;
            };
            layoutConfig?: LayoutConfig;
            onClick?: Function;
            superview?: Superview;
            callbacks: Map<String, Function>;
            callback2Id(f: Function): string;
            findViewByTag(tag: string): View | undefined;
            constructor();
            /** Anchor start*/
            get left(): number;
            set left(v: number);
            get right(): number;
            set right(v: number);
            get top(): number;
            set top(v: number);
            get bottom(): number;
            set bottom(v: number);
            get centerX(): number;
            get centerY(): number;
            set centerX(v: number);
            set centerY(v: number);
            get dirtyProps(): {
                    [index: string]: Model;
            };
            nativeViewModel: NativeViewModel;
            viewType(): any;
            onPropertyChanged(propKey: string, oldV: Model, newV: Model): void;
            clean(): void;
            isDirty(): boolean;
            responseCallback(id: string, ...args: any): any;
            toModel(): NativeViewModel;
            let(block: (it: this) => void): void;
            also(block: (it: this) => void): this;
            apply(config: Partial<this>): this;
            in(group: Group): this;
            nativeChannel(context: BridgeContext, name: string): (args?: any) => Promise<any>;
            getWidth(context: BridgeContext): Promise<number>;
            getHeight(context: BridgeContext): Promise<number>;
            getX(context: BridgeContext): Promise<number>;
            getY(context: BridgeContext): Promise<number>;
            getLocationOnScreen(context: BridgeContext): Promise<{
                    x: number;
                    y: number;
            }>;
            /**++++++++++transform++++++++++*/
            translationX?: number;
            translationY?: number;
            /**
                * float [0,..1]
                */
            scaleX?: number;
            scaleY?: number;
            pivotX?: number;
            pivotY?: number;
            /**
                * rotation*PI
                * In Z
                */
            rotation?: number;
            /**
                * rotation*PI
                * In X
                */
            rotationX?: number;
            /**
                * rotation*PI
                * In Y
                */
            rotationY?: number;
            /**
                * Determines the distance between the z=0 plane and the user in order to give a 3D-positioned element some perspective.
                * Default is 200
                */
            perspective?: number;
            /**
                * Only affected when its superview or itself is FlexLayout.
                */
            flexConfig?: FlexConfig;
            set props(props: Partial<this>);
            set parent(v: Group);
            set ref(ref: Ref<this>);
            doAnimation(context: BridgeContext, animation: IAnimation): Promise<void>;
            clearAnimation(context: BridgeContext, animation: IAnimation): Promise<void>;
            cancelAnimation(context: BridgeContext, animation: IAnimation): Promise<void>;
    }
    export abstract class Superview extends View {
            subviewById(id: string): View | undefined;
            findViewByTag(tag: string): View | undefined;
            abstract allSubviews(): Iterable<View>;
            isDirty(): boolean;
            clean(): void;
            toModel(): NativeViewModel;
    }
    export type ViewArray = View[];
    export type ViewFragment = View | ViewArray;
    export abstract class Group extends Superview implements JSX.ElementChildrenAttribute {
            readonly children: View[];
            allSubviews(): View[];
            addChild(view: View): void;
            removeChild(view: View): void;
            removeAllChildren(): void;
            set innerElement(e: View | ViewFragment | ViewFragment[] | undefined | null);
    }
    export {};
}

declare module 'doric/lib/src/ui/animation' {
    import { Color } from "doric/lib/src/util/color";
    import { Modeling, Model } from "doric/lib/src/util/types";
    export type AnimatedKey = "translationX" | "translationY" | "scaleX" | "scaleY" | "rotation" | "pivotX" | "pivotY" | "rotationX" | "rotationY" | "backgroundColor" | "alpha";
    export enum RepeatMode {
            RESTART = 1,
            REVERSE = 2
    }
    export interface IAnimation extends Modeling {
            duration: number;
            delay?: number;
            id: string;
    }
    export interface Changeable {
            fromValue: number;
            toValue: number;
            key: AnimatedKey;
            repeatCount?: number;
            repeatMode?: RepeatMode;
            keyFrames?: {
                    percent: number;
                    value: number;
            }[];
    }
    export enum FillMode {
            /**
                * The receiver is removed from the presentation when the animation is completed.
                */
            Removed = 0,
            /**
                * The receiver remains visible in its final state when the animation is completed.
                */
            Forward = 1,
            /**
                * The receiver clamps values before zero to zero when the animation is completed.
                */
            Backward = 2,
            /**
                * The receiver clamps values at both ends of the object’s time space
                */
            Both = 3
    }
    export enum TimingFunction {
            /**
                * The system default timing function. Use this function to ensure that the timing of your animations matches that of most system animations.
                */
            Default = 0,
            /**
                * Linear pacing, which causes an animation to occur evenly over its duration.
                */
            Linear = 1,
            /**
                * Ease-in pacing, which causes an animation to begin slowly and then speed up as it progresses.
                */
            EaseIn = 2,
            /**
                * Ease-out pacing, which causes an animation to begin quickly and then slow as it progresses.
                */
            EaseOut = 3,
            /**
                * Ease-in-ease-out pacing, which causes an animation to begin slowly, accelerate through the middle of its duration, and then slow again before completing.
                */
            EaseInEaseOut = 4
    }
    abstract class Animation implements IAnimation {
            changeables: Map<AnimatedKey, Changeable>;
            duration: number;
            repeatCount?: number;
            repeatMode?: RepeatMode;
            delay?: number;
            fillMode: FillMode;
            timingFunction?: TimingFunction;
            id: string;
            toModel(): {
                    type: string;
                    delay: number | undefined;
                    duration: number;
                    changeables: {
                            key: AnimatedKey;
                            fromValue: number;
                            toValue: number;
                            keyFrames: {
                                    percent: number;
                                    value: number;
                            }[] | undefined;
                    }[];
                    repeatCount: number | undefined;
                    repeatMode: RepeatMode | undefined;
                    fillMode: FillMode;
                    timingFunction: TimingFunction | undefined;
                    id: string;
            };
    }
    export class ScaleAnimation extends Animation {
            constructor();
            set xKeyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
            set yKeyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
            set fromScaleX(v: number);
            get fromScaleX(): number;
            set toScaleX(v: number);
            get toScaleX(): number;
            set fromScaleY(v: number);
            get fromScaleY(): number;
            set toScaleY(v: number);
            get toScaleY(): number;
    }
    export class TranslationAnimation extends Animation {
            constructor();
            set xKeyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
            set yKeyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
            set fromTranslationX(v: number);
            get fromTranslationX(): number;
            set toTranslationX(v: number);
            get toTranslationX(): number;
            set fromTranslationY(v: number);
            get fromTranslationY(): number;
            set toTranslationY(v: number);
            get toTranslationY(): number;
    }
    /**
        * Rotation range is [0..2]
        */
    export class RotationAnimation extends Animation {
            constructor();
            set fromRotation(v: number);
            get fromRotation(): number;
            set toRotation(v: number);
            get toRotation(): number;
            set keyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
    }
    /**
        * Rotation range is [0..2]
        */
    export class RotationXAnimation extends Animation {
            constructor();
            set fromRotation(v: number);
            get fromRotation(): number;
            set toRotation(v: number);
            get toRotation(): number;
            set keyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
    }
    /**
        * Rotation range is [0..2]
        */
    export class RotationYAnimation extends Animation {
            constructor();
            set fromRotation(v: number);
            get fromRotation(): number;
            set toRotation(v: number);
            get toRotation(): number;
            set keyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
    }
    export class BackgroundColorAnimation extends Animation {
            constructor();
            set fromColor(color: Color);
            get fromColor(): Color;
            set toColor(v: Color);
            get toColor(): Color;
            set keyFrames(keyFrames: {
                    percent: number;
                    value: Color;
            }[]);
    }
    /**
        * Alpha range is [0..1]
        */
    export class AlphaAnimation extends Animation {
            constructor();
            set from(v: number);
            get from(): number;
            set to(v: number);
            get to(): number;
            set keyFrames(keyFrames: {
                    percent: number;
                    value: number;
            }[]);
    }
    export class AnimationSet implements IAnimation {
            delay?: number;
            id: string;
            addAnimation(anim: IAnimation): void;
            get duration(): number;
            set duration(v: number);
            toModel(): {
                    animations: Model;
                    delay: number | undefined;
                    id: string;
            };
    }
    export {};
}

declare module 'doric/lib/src/widget/layouts' {
    import { Group, View } from "doric/lib/src/ui/view";
    import { Gravity } from "doric/lib/src/util/gravity";
    export class Stack extends Group {
    }
    export class Root extends Stack {
    }
    class LinearLayout extends Group {
        space?: number;
        gravity?: Gravity;
    }
    export class VLayout extends LinearLayout {
    }
    export class HLayout extends LinearLayout {
    }
    export function stack(views: View[], config?: Partial<Stack>): Stack;
    export function hlayout(views: View[], config?: Partial<HLayout>): HLayout;
    export function vlayout(views: View[], config?: Partial<VLayout>): VLayout;
    export class FlexLayout extends Group {
    }
    export function flexlayout(views: View[], config?: Partial<FlexLayout>): FlexLayout;
    export {};
}

declare module 'doric/lib/src/widget/text' {
    import { View } from "doric/lib/src/ui/view";
    import { Color, GradientColor } from "doric/lib/src/util/color";
    import { Gravity } from "doric/lib/src/util/gravity";
    import { Resource } from "doric/lib/src/util/resource";
    export enum TruncateAt {
        End = 0,
        Middle = 1,
        Start = 2,
        Clip = 3
    }
    export class Text extends View implements JSX.ElementChildrenAttribute {
        text?: string;
        textColor?: Color | GradientColor;
        textSize?: number;
        maxLines?: number;
        textAlignment?: Gravity;
        fontStyle?: "normal" | "bold" | "italic" | "bold_italic";
        font?: string | Resource;
        maxWidth?: number;
        maxHeight?: number;
        lineSpacing?: number;
        strikethrough?: boolean;
        underline?: boolean;
        htmlText?: string;
        truncateAt?: TruncateAt;
        set innerElement(e: string);
    }
    export function text(config: Partial<Text>): Text;
}

declare module 'doric/lib/src/widget/image' {
    import { View } from "doric/lib/src/ui/view";
    import { Color } from "doric/lib/src/util/color";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { Resource } from "doric/lib/src/util/resource";
    export enum ScaleType {
            ScaleToFill = 0,
            ScaleAspectFit = 1,
            ScaleAspectFill = 2,
            Tile = 3
    }
    export class Image extends View {
            /**
                * Set pixels for image directly
             */
            imagePixels?: {
                    width: number;
                    height: number;
                    pixels: ArrayBuffer;
            };
            /**
                * This could be loaded by customized resource loader
             */
            image?: Resource;
            imageUrl?: string;
            /**
                * Read image from local file system.
             */
            imageFilePath?: string;
            /**
                * Read image from local path
                * For android,it based on assets dir.
                * For iOS,it based on main bundle dir.
             */
            imagePath?: string;
            /**
                * Read image from resource
                * For android,it will try to read from drawable.
                * For iOS,it will try to read from Image.Assets.
                */
            imageRes?: string;
            imageBase64?: string;
            scaleType?: ScaleType;
            isBlur?: boolean;
            /**
                * Display while image is loading
                * Local file name
                */
            placeHolderImage?: string;
            placeHolderImageBase64?: string;
            /**
                * Display while image is loading
                * Color
                * This priority is lower than placeHolderImage
                */
            placeHolderColor?: Color;
            /**
                * Display while image is failed to load
                * It can be file name in local path
                */
            errorImage?: string;
            errorImageBase64?: string;
            /**
                * Display while image is failed to load
                * Color
                * This priority is lower than errorImage
                */
            errorColor?: Color;
            loadCallback?: (image: {
                    width: number;
                    height: number;
                    animated: boolean;
            } | undefined) => void;
            /**
                * Default is Environment.screenScale.
                */
            imageScale?: number;
            /**
                * Unit in pixel
                */
            stretchInset?: {
                    left: number;
                    top: number;
                    right: number;
                    bottom: number;
            };
            /**
                * Called if loaded image is animated and played end.
                */
            onAnimationEnd?: () => void;
            isAnimating(context: BridgeContext): Promise<boolean>;
            startAnimating(context: BridgeContext): Promise<any>;
            stopAnimating(context: BridgeContext): Promise<any>;
            getImageInfo(context: BridgeContext): Promise<{
                    width: number;
                    height: number;
                    mimeType: string;
            }>;
            getImagePixels(context: BridgeContext): Promise<ArrayBuffer>;
            setImagePixels(context: BridgeContext, image: {
                    width: number;
                    height: number;
                    pixels: ArrayBuffer;
            }): Promise<void>;
    }
    export function image(config: Partial<Image>): Image;
}

declare module 'doric/lib/src/widget/list' {
    import { View, Superview, NativeViewModel } from "doric/lib/src/ui/view";
    import { Stack } from "doric/lib/src/widget/layouts";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { Color } from "doric/lib/src/util/color";
    export class ListItem extends Stack {
            /**
                * Set to reuse native view
                */
            identifier?: string;
            actions?: {
                    title: string;
                    backgroundColor?: Color;
                    callback: () => void;
            }[];
    }
    export class List extends Superview {
            allSubviews(): ListItem[];
            itemCount: number;
            renderItem: (index: number) => ListItem;
            batchCount: number;
            onLoadMore?: () => void;
            loadMore?: boolean;
            loadMoreView?: ListItem;
            onScroll?: (offset: {
                    x: number;
                    y: number;
            }) => void;
            onScrollEnd?: (offset: {
                    x: number;
                    y: number;
            }) => void;
            scrolledPosition?: number;
            scrollable?: boolean;
            /**
                * Take effect only on iOS
                */
            bounces?: boolean;
            canDrag?: boolean;
            onDragging?: (from: number, to: number) => void;
            onDragged?: (from: number, to: number) => void;
            scrollToItem(context: BridgeContext, index: number, config?: {
                    animated?: boolean;
            }): Promise<any>;
            /**
                * @param context
                * @returns Returns array of visible view's index.
                */
            findVisibleItems(context: BridgeContext): Promise<number[]>;
            /**
                * @param context
                * @returns Returns array of completely visible view's index.
                */
            findCompletelyVisibleItems(context: BridgeContext): Promise<number[]>;
            reset(): void;
            toModel(): NativeViewModel;
    }
    export function list(config: Partial<List>): List;
    export function listItem(item: View | View[], config?: Partial<ListItem>): ListItem;
}

declare module 'doric/lib/src/widget/slider' {
    import { Superview, View } from "doric/lib/src/ui/view";
    import { Stack } from "doric/lib/src/widget/layouts";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export class SlideItem extends Stack {
            /**
                * Set to reuse native view
                */
            identifier?: string;
    }
    export class Slider extends Superview {
            allSubviews(): IterableIterator<SlideItem>;
            itemCount: number;
            renderPage: (index: number) => SlideItem;
            batchCount: number;
            onPageSlided?: (index: number) => void;
            loop?: boolean;
            scrollable?: boolean;
            /**
                * Take effect only on iOS
                */
            bounces?: boolean;
            slidePage(context: BridgeContext, page: number, smooth?: boolean): Promise<any>;
            getSlidedPage(context: BridgeContext): Promise<number>;
    }
    export function slider(config: Partial<Slider>): Slider;
    export function slideItem(item: View | View[], config?: Partial<SlideItem>): SlideItem;
}

declare module 'doric/lib/src/widget/scroller' {
    import { Superview, View, NativeViewModel } from 'doric/lib/src/ui/view';
    import { BridgeContext } from 'doric/lib/src/runtime/global';
    export function scroller(content: View, config?: Partial<Scroller>): Scroller;
    export class Scroller extends Superview implements JSX.ElementChildrenAttribute {
        content: View;
        contentOffset?: {
            x: number;
            y: number;
        };
        onScroll?: (offset: {
            x: number;
            y: number;
        }) => void;
        onScrollEnd?: (offset: {
            x: number;
            y: number;
        }) => void;
        scrollable?: boolean;
        /**
          * Take effect only on iOS
          */
        bounces?: boolean;
        allSubviews(): View[];
        toModel(): NativeViewModel;
        scrollTo(context: BridgeContext, offset: {
            x: number;
            y: number;
        }, animated?: boolean): Promise<any>;
        scrollBy(context: BridgeContext, offset: {
            x: number;
            y: number;
        }, animated?: boolean): Promise<any>;
        set innerElement(e: View);
    }
}

declare module 'doric/lib/src/widget/refreshable' {
    import { View, Superview, NativeViewModel } from "doric/lib/src/ui/view";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export class Refreshable extends Superview implements JSX.ElementChildrenAttribute {
        content: View;
        header?: View;
        onRefresh?: () => void;
        allSubviews(): View[];
        setRefreshable(context: BridgeContext, refreshable: boolean): Promise<any>;
        setRefreshing(context: BridgeContext, refreshing: boolean): Promise<any>;
        isRefreshable(context: BridgeContext): Promise<boolean>;
        isRefreshing(context: BridgeContext): Promise<boolean>;
        toModel(): NativeViewModel;
        set innerElement(e: View | [View, View]);
    }
    export function refreshable(config: Partial<Refreshable>): Refreshable;
    export interface IPullable {
        startAnimation(): void;
        stopAnimation(): void;
        setPullingDistance(distance: number): void;
    }
    export function pullable(v: View, config: IPullable): View;
}

declare module 'doric/lib/src/widget/flowlayout' {
    import { Stack } from 'doric/lib/src/widget/layouts';
    import { Superview, View, NativeViewModel } from 'doric/lib/src/ui/view';
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export class FlowLayoutItem extends Stack {
            /**
             * Set to reuse native view
             */
            identifier?: string;
            /**
                * When set to true, the item will layout using all span area.
                * LoadMoreView is default to true.
                */
            fullSpan?: boolean;
    }
    export class FlowLayout extends Superview {
            allSubviews(): FlowLayoutItem[];
            columnCount: number;
            columnSpace?: number;
            rowSpace?: number;
            itemCount: number;
            renderItem: (index: number) => FlowLayoutItem;
            batchCount: number;
            onLoadMore?: () => void;
            loadMore?: boolean;
            loadMoreView?: FlowLayoutItem;
            onScroll?: (offset: {
                    x: number;
                    y: number;
            }) => void;
            onScrollEnd?: (offset: {
                    x: number;
                    y: number;
            }) => void;
            scrollable?: boolean;
            /**
                * Take effect only on iOS
                */
            bounces?: boolean;
            /**
                * @param context
                * @returns Returns array of visible view's index.
                */
            findVisibleItems(context: BridgeContext): Promise<number[]>;
            /**
                * @param context
                * @returns Returns array of completely visible view's index.
                */
            findCompletelyVisibleItems(context: BridgeContext): Promise<number[]>;
            reset(): void;
            toModel(): NativeViewModel;
    }
    export function flowlayout(config: Partial<FlowLayout>): FlowLayout;
    export function flowItem(item: View | View[], config?: Partial<FlowLayoutItem>): FlowLayoutItem;
}

declare module 'doric/lib/src/widget/input' {
    import { View } from "doric/lib/src/ui/view";
    import { Color } from "doric/lib/src/util/color";
    import { Gravity } from "doric/lib/src/util/gravity";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export enum ReturnKeyType {
        Default = 0,
        Done = 1,
        Search = 2,
        Next = 3,
        Go = 4,
        Send = 5
    }
    export class Input extends View {
        text?: string;
        textColor?: Color;
        textSize?: number;
        font?: string;
        hintText?: string;
        hintFont?: string;
        inputType?: InputType;
        hintTextColor?: Color;
        multiline?: boolean;
        textAlignment?: Gravity;
        onTextChange?: (text: string) => void;
        onFocusChange?: (focused: boolean) => void;
        maxLength?: number;
        password?: boolean;
        editable?: boolean;
        returnKeyType?: ReturnKeyType;
        onSubmitEditing?: (text: string) => void;
        enableHorizontalScrollBar?: boolean;
        enableVerticalScrollBar?: boolean;
        /**
          * Called before text is changed
          * @param editing: text already in box
          * @param replacement: text which will replace part of editing
          * @param start: the start index of replacing part
          * @param length: the length of replacing part
          *
          * @returns: true means the replacement will take effect, otherwise does not
          */
        beforeTextChange?: (change: {
            editing: string;
            start: number;
            length: number;
            replacement: string;
        }) => boolean;
        getText(context: BridgeContext): Promise<string>;
        setSelection(context: BridgeContext, start: number, end?: number): Promise<any>;
        getSelection(context: BridgeContext): Promise<{
            start: number;
            end: number;
        }>;
        requestFocus(context: BridgeContext): Promise<any>;
        releaseFocus(context: BridgeContext): Promise<any>;
    }
    export enum InputType {
        Default = 0,
        Number = 1,
        Decimal = 2,
        Alphabet = 3,
        Phone = 4
    }
    export function input(config: Partial<Input>): Input;
}

declare module 'doric/lib/src/widget/nestedSlider' {
    import { Group, View } from 'doric/lib/src/ui/view';
    import { BridgeContext } from 'doric/lib/src/runtime/global';
    export class NestedSlider extends Group {
        onPageSlided?: (index: number) => void;
        scrollable?: boolean;
        /**
          * Take effect only on iOS
          */
        bounces?: boolean;
        addSlideItem(view: View): void;
        slidePage(context: BridgeContext, page: number, smooth?: boolean): Promise<any>;
        getSlidedPage(context: BridgeContext): Promise<number>;
    }
}

declare module 'doric/lib/src/widget/draggable' {
    import { View } from "doric/lib/src/ui/view";
    import { Stack } from "doric/lib/src/widget/layouts";
    /**
        * @deprecated The class should not be used, please use GestureContainer class instead
        */
    export class Draggable extends Stack {
            onDrag?: (x: number, y: number) => void;
    }
    /**
        * @deprecated The function should not be used, please use gestureContainer function instead
        */
    export function draggable(views: View | View[], config?: Partial<Draggable>): Draggable;
}

declare module 'doric/lib/src/widget/switch' {
    import { View } from "doric/lib/src/ui/view";
    import { Color } from "doric/lib/src/util/color";
    export class Switch extends View {
            /**
                * True is on ,false is off,defalut is off.
                */
            state?: boolean;
            /**
                * Switch change callback
                */
            onSwitch?: (state: boolean) => void;
            offTintColor?: Color;
            onTintColor?: Color;
            thumbTintColor?: Color;
    }
    export function switchView(config: Partial<Switch>): Switch;
}

declare module 'doric/lib/src/widget/gesture' {
    import { View } from "doric/lib/src/ui/view";
    import { Stack } from "doric/lib/src/widget/layouts";
    export enum SwipeOrientation {
            LEFT = 0,
            RIGHT = 1,
            TOP = 2,
            BOTTOM = 3
    }
    export class GestureContainer extends Stack {
            onSingleTap?: () => void;
            onDoubleTap?: () => void;
            onLongPress?: () => void;
            /**
                * Called when the fingers in pinching on screen
                * @param scale: the numeric value of scale on pinch
                */
            onPinch?: (scale: number) => void;
            /**
                * Called when the fingers are scrolling or paning
                * @param dx: the value of the change on the x-axis
                * @param dy: the value of the change on the y-axis
                */
            onPan?: (dx: number, dy: number) => void;
            /**
                * Called when the fingers are scrolling or paning
                * @param dAngle: the value of the angle change from last rotate in radian
                */
            onRotate?: (dAngle: number) => void;
            /**
                * Called when the fingers has swiped on screen
                * @param orientation: the orientation of this swipe
                */
            onSwipe?: (orientation: SwipeOrientation) => void;
            /**
                * Called when the finger touch down on the screen
                * @param x: the value of event occurs on the x-axis
                * @param y: the value of event occurs on the y-axis
                */
            onTouchDown?: (event: {
                    x: number;
                    y: number;
            }) => void;
            /**
                * Called when the finger moving on the screen
                * @param x: the value of event occurs on the x-axis
                * @param y: the value of event occurs on the y-axis
                */
            onTouchMove?: (event: {
                    x: number;
                    y: number;
            }) => void;
            /**
                * Called when the finger touch up off from the screen
                * @param x: the value of event occurs on the x-axis
                * @param y: the value of event occurs on the y-axis
                */
            onTouchUp?: (event: {
                    x: number;
                    y: number;
            }) => void;
            /**
                * Called when the finger leave from screen
                * @param x: the value of event occurs on the x-axis
                * @param y: the value of event occurs on the y-axis
                */
            onTouchCancel?: (event: {
                    x: number;
                    y: number;
            }) => void;
    }
    export function gestureContainer(views: View | View[], config?: Partial<GestureContainer>): GestureContainer;
}

declare module 'doric/lib/src/widget/effect' {
    import { Stack } from "doric/lib/src/widget/layouts";
    import { View } from "doric/lib/src/ui/view";
    export class BlurEffect extends Stack {
            /**
                * Specify the effective rectangle.
                * If not set, the default is the entire area.
                */
            effectiveRect?: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
            };
            /**
                * Specify the radius of blur effect.
                * If not set, the default value is 15.
                * Suggested value is from 1 to 25.
                */
            radius?: number;
    }
    export class AeroEffect extends Stack {
            /**
                * Specify the effective rectangle.
                * If not set, the default is the entire area.
                */
            effectiveRect?: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
            };
            /**
                * Specify the area of the view is lighter or darker than the underlying view.
                * If not set, the default is light.
                */
            style?: "light" | "dark" | "extraLight";
    }
    export function blurEffect(views: View | View[], config?: Partial<BlurEffect>): BlurEffect;
    export function aeroEffect(views: View | View[], config?: Partial<AeroEffect>): AeroEffect;
}

declare module 'doric/lib/src/native/modal' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { Gravity } from "doric/lib/src/util/gravity";
    export function modal(context: BridgeContext): {
        toast: (msg: string, gravity?: Gravity) => void;
        alert: (arg: string | {
            title: string;
            msg: string;
            okLabel?: string;
        }) => Promise<any>;
        confirm: (arg: string | {
            title: string;
            msg: string;
            okLabel?: string;
            cancelLabel?: string;
        }) => Promise<any>;
        prompt: (arg: {
            title?: string;
            msg?: string;
            okLabel?: string;
            cancelLabel?: string;
            text?: string;
            defaultText?: string;
        }) => Promise<string>;
    };
}

declare module 'doric/lib/src/native/navbar' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { Color } from "doric/lib/src/util/color";
    import { View } from "doric/lib/src/ui/view";
    export function navbar(context: BridgeContext): {
        isHidden: () => Promise<boolean>;
        setHidden: (hidden: boolean) => Promise<any>;
        setTitle: (title: string) => Promise<any>;
        setBgColor: (color: Color) => Promise<any>;
        setLeft: (view: View) => Promise<any>;
        setRight: (view: View) => Promise<any>;
        setCenter: (view: View) => Promise<any>;
    };
}

declare module 'doric/lib/src/native/navigator' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { Panel } from "doric/lib/src/ui/panel";
    import { ClassType } from "doric/lib/src/util/types";
    export function internalScheme(context: BridgeContext, panelClass: ClassType<Panel>): string;
    export function navigator(context: BridgeContext): {
        push: (source: string | ClassType<Panel>, config?: {
            alias?: string;
            animated?: boolean;
            extra?: object;
            singlePage?: boolean;
        }) => Promise<any>;
        pop: (animated?: boolean) => Promise<any>;
        popSelf: (animated?: boolean) => Promise<any>;
        popToRoot: (animated?: boolean) => Promise<any>;
        openUrl: (url: string) => Promise<any>;
    };
}

declare module 'doric/lib/src/native/network' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export interface IRequest {
        url?: string;
        method?: "get" | "post" | "put" | "delete";
        headers?: {
            [index: string]: string;
        };
        params?: {
            [index: string]: string;
        };
        data?: object | string;
        timeout?: number;
    }
    export interface IResponse {
        data: string;
        status: number;
        headers?: {
            [index: string]: string;
        };
    }
    export function network(context: BridgeContext): {
        request: (config: IRequest) => Promise<IResponse>;
        get: (url: string, config?: IRequest) => Promise<IResponse>;
        post: (url: string, data?: object | string, config?: IRequest) => Promise<IResponse>;
        put: (url: string, data?: object | string, config?: IRequest) => Promise<IResponse>;
        delete: (url: string, data?: object | string, config?: IRequest) => Promise<IResponse>;
    };
}

declare module 'doric/lib/src/native/storage' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export function storage(context: BridgeContext): {
        setItem: (key: string, value: string, zone?: string) => Promise<any>;
        getItem: (key: string, zone?: string) => Promise<string>;
        remove: (key: string, zone?: string) => Promise<any>;
        clear: (zone: string) => Promise<any>;
    };
}

declare module 'doric/lib/src/native/popover' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { View } from "doric/lib/src/ui/view";
    export function popover(context: BridgeContext): {
        show: (view: View) => Promise<any>;
        dismiss: (view?: View | undefined) => Promise<any>;
    };
}

declare module 'doric/lib/src/native/animate' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    /**
      * Only supports x,y,width,height,corner(just for four corners),rotation,bgColor,
      * @param panel @see Panel
      */
    export function animate(context: BridgeContext): (args: {
        animations: () => void;
        duration: number;
    }) => Promise<unknown>;
}

declare module 'doric/lib/src/native/notification' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export function notification(context: BridgeContext): {
        publish: (args: {
            biz?: string;
            name: string;
            data?: object;
            androidSystem?: boolean;
            permission?: string;
        }) => Promise<any>;
        subscribe: (args: {
            biz?: string | undefined;
            name: string;
            callback: (data?: any) => void;
            androidSystem?: boolean | undefined;
            permission?: string | undefined;
        }) => Promise<string>;
        unsubscribe: (subscribeId: string) => Promise<any>;
    };
}

declare module 'doric/lib/src/native/statusbar' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { Color } from "doric/lib/src/util/color";
    export enum StatusBarMode {
        LIGHT = 0,
        DARK = 1
    }
    export function statusbar(context: BridgeContext): {
        setHidden: (hidden: boolean) => Promise<any>;
        setMode: (mode: StatusBarMode) => Promise<any>;
        setColor: (color: Color) => Promise<any>;
    };
}

declare module 'doric/lib/src/native/coordinator' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { Scroller } from "doric/lib/src/widget/scroller";
    import { List } from "doric/lib/src/widget/list";
    import { FlowLayout } from "doric/lib/src/widget/flowlayout";
    import { View } from "doric/lib/src/ui/view";
    import { Color } from "doric/lib/src/util/color";
    export function coordinator(context: BridgeContext): {
        verticalScrolling: (argument: {
            scrollable: Scroller | List | FlowLayout;
            scrollRange: {
                start: number;
                end: number;
            };
            target: View | "NavBar";
            changing: {
                name: "backgroundColor" | "width" | "height" | "x" | "y" | "alpha";
                start: number | Color;
                end: number | Color;
            };
        }) => void;
    };
}

declare module 'doric/lib/src/native/notch' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export function notch(context: BridgeContext): {
        inset: () => Promise<{
            top: number;
            left: number;
            bottom: number;
            right: number;
        }>;
    };
}

declare module 'doric/lib/src/native/keyboard' {
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export function keyboard(context: BridgeContext): {
        subscribe: (callback: (data: {
            oldBottomMargin: number;
            oldHeight: number;
            bottomMargin: number;
            height: number;
        }) => void) => Promise<string>;
        unsubscribe: (subscribeId: string) => Promise<any>;
    };
}

declare module 'doric/lib/src/native/resourceLoader' {
    import { Resource } from "doric/lib/src/util/resource";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export function resourceLoader(context: BridgeContext): {
        load: (resource: Resource) => Promise<ArrayBuffer>;
    };
}

declare module 'doric/lib/src/native/imageDecoder' {
    import { Resource } from "doric/lib/src/util/resource";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    export function imageDecoder(context: BridgeContext): {
        getImageInfo: (resource: Resource) => Promise<{
            width: number;
            height: number;
            mimeType: string;
        }>;
        decodeToPixels: (resource: Resource) => Promise<ArrayBuffer>;
    };
}

declare module 'doric/lib/src/util/color' {
    import { Modeling } from "doric/lib/src/util/types";
    /**
      *  Store color as format AARRGGBB or RRGGBB
      */
    export class Color implements Modeling {
        static BLACK: Color;
        static DKGRAY: Color;
        static GRAY: Color;
        static LTGRAY: Color;
        static WHITE: Color;
        static RED: Color;
        static GREEN: Color;
        static BLUE: Color;
        static YELLOW: Color;
        static CYAN: Color;
        static MAGENTA: Color;
        static TRANSPARENT: Color;
        _value: number;
        constructor(v: number);
        static parse(str: string): Color;
        static safeParse(str: string, defVal?: Color): Color;
        alpha(v: number): Color;
        toModel(): number;
    }
    export enum GradientOrientation {
        /** draw the gradient from the top to the bottom */
        TOP_BOTTOM = 0,
        /** draw the gradient from the top-right to the bottom-left */
        TR_BL = 1,
        /** draw the gradient from the right to the left */
        RIGHT_LEFT = 2,
        /** draw the gradient from the bottom-right to the top-left */
        BR_TL = 3,
        /** draw the gradient from the bottom to the top */
        BOTTOM_TOP = 4,
        /** draw the gradient from the bottom-left to the top-right */
        BL_TR = 5,
        /** draw the gradient from the left to the right */
        LEFT_RIGHT = 6,
        /** draw the gradient from the top-left to the bottom-right */
        TL_BR = 7
    }
    export interface GradientColor {
        start?: Color;
        end?: Color;
        colors?: Array<Color>;
        locations?: Array<Number>;
        orientation: GradientOrientation;
    }
}

declare module 'doric/lib/src/util/gravity' {
    import { Modeling } from "doric/lib/src/util/types";
    export const LEFT: number;
    export const RIGHT: number;
    export const TOP: number;
    export const BOTTOM: number;
    export const CENTER_X: number;
    export const CENTER_Y: number;
    export const CENTER: number;
    export class Gravity implements Modeling {
        val: number;
        left(): Gravity;
        right(): Gravity;
        top(): Gravity;
        bottom(): Gravity;
        center(): Gravity;
        centerX(): Gravity;
        centerY(): Gravity;
        toModel(): number;
        static Center: Gravity;
        static CenterX: Gravity;
        static CenterY: Gravity;
        static Left: Gravity;
        static Right: Gravity;
        static Top: Gravity;
        static Bottom: Gravity;
    }
    export function gravity(): Gravity;
}

declare module 'doric/lib/src/util/layoutconfig' {
    import { Gravity } from "doric/lib/src/util/gravity";
    import { Modeling } from "doric/lib/src/util/types";
    export enum LayoutSpec {
            /**
                * Depends on what's been set on width or height.
             */
            JUST = 0,
            /**
                * Depends on it's content.
                */
            FIT = 1,
            /**
                * Extend as much as parent let it take.
                */
            MOST = 2
    }
    export interface LayoutConfig {
            widthSpec?: LayoutSpec;
            heightSpec?: LayoutSpec;
            margin?: {
                    left?: number;
                    right?: number;
                    top?: number;
                    bottom?: number;
            };
            alignment?: Gravity;
            weight?: number;
            maxWidth?: number;
            maxHeight?: number;
            minWidth?: number;
            minHeight?: number;
    }
    export class LayoutConfigImpl implements LayoutConfig, Modeling {
            widthSpec?: LayoutSpec;
            heightSpec?: LayoutSpec;
            margin?: {
                    left?: number;
                    right?: number;
                    top?: number;
                    bottom?: number;
            };
            alignment?: Gravity;
            weight?: number;
            maxWidth?: number;
            maxHeight?: number;
            minWidth?: number;
            minHeight?: number;
            fit(): this;
            fitWidth(): this;
            fitHeight(): this;
            most(): this;
            mostWidth(): this;
            mostHeight(): this;
            just(): this;
            justWidth(): this;
            justHeight(): this;
            configWidth(w: LayoutSpec): this;
            configHeight(h: LayoutSpec): this;
            configMargin(m: {
                    left?: number;
                    right?: number;
                    top?: number;
                    bottom?: number;
            }): this;
            configAlignment(a: Gravity): this;
            configWeight(w: number): this;
            configMaxWidth(v: number): this;
            configMaxHeight(v: number): this;
            configMinWidth(v: number): this;
            configMinHeight(v: number): this;
            toModel(): {
                    widthSpec: LayoutSpec | undefined;
                    heightSpec: LayoutSpec | undefined;
                    margin: {
                            left?: number | undefined;
                            right?: number | undefined;
                            top?: number | undefined;
                            bottom?: number | undefined;
                    } | undefined;
                    alignment: number | undefined;
                    weight: number | undefined;
                    minWidth: number | undefined;
                    maxWidth: number | undefined;
                    minHeight: number | undefined;
                    maxHeight: number | undefined;
            };
    }
    export function layoutConfig(): LayoutConfigImpl;
}

declare module 'doric/lib/src/util/log' {
    export function log(...args: any): void;
    export function loge(...message: any): void;
    export function logw(...message: any): void;
}

declare module 'doric/lib/src/util/uniqueId' {
    export function uniqueId(prefix: string): string;
}

declare module 'doric/lib/src/util/flexbox' {
    import { Modeling } from "doric/lib/src/util/types";
    enum ValueType {
        Undefined = 0,
        Point = 1,
        Percent = 2,
        Auto = 3
    }
    export class FlexTypedValue implements Modeling {
        type: ValueType;
        value: number;
        constructor(type: ValueType);
        static Auto: FlexTypedValue;
        static percent(v: number): FlexTypedValue;
        static point(v: number): FlexTypedValue;
        toModel(): {
            type: ValueType;
            value: number;
        };
    }
    export enum FlexDirection {
        COLUMN = 0,
        COLUMN_REVERSE = 1,
        ROW = 2,
        ROW_REVERSE = 3
    }
    export enum Align {
        AUTO = 0,
        FLEX_START = 1,
        CENTER = 2,
        FLEX_END = 3,
        STRETCH = 4,
        BASELINE = 5,
        SPACE_BETWEEN = 6,
        SPACE_AROUND = 7
    }
    export enum Justify {
        FLEX_START = 0,
        CENTER = 1,
        FLEX_END = 2,
        SPACE_BETWEEN = 3,
        SPACE_AROUND = 4,
        SPACE_EVENLY = 5
    }
    export enum Direction {
        INHERIT = 0,
        LTR = 1,
        RTL = 2
    }
    export enum PositionType {
        RELATIVE = 0,
        ABSOLUTE = 1
    }
    export enum Wrap {
        NO_WRAP = 0,
        WRAP = 1,
        WRAP_REVERSE = 2
    }
    export enum OverFlow {
        VISIBLE = 0,
        HIDDEN = 1,
        SCROLL = 2
    }
    export enum Display {
        FLEX = 0,
        NONE = 1
    }
    export type FlexValue = FlexTypedValue | number;
    export interface FlexConfig {
        direction?: Direction;
        flexDirection?: FlexDirection;
        justifyContent?: Justify;
        alignContent?: Align;
        alignItems?: Align;
        alignSelf?: Align;
        positionType?: PositionType;
        flexWrap?: Wrap;
        overFlow?: OverFlow;
        display?: Display;
        flex?: number;
        flexGrow?: number;
        flexShrink?: number;
        flexBasis?: FlexValue;
        marginLeft?: FlexValue;
        marginRight?: FlexValue;
        marginTop?: FlexValue;
        marginBottom?: FlexValue;
        marginStart?: FlexValue;
        marginEnd?: FlexValue;
        marginHorizontal?: FlexValue;
        marginVertical?: FlexValue;
        margin?: FlexValue;
        paddingLeft?: FlexValue;
        paddingRight?: FlexValue;
        paddingTop?: FlexValue;
        paddingBottom?: FlexValue;
        paddingStart?: FlexValue;
        paddingEnd?: FlexValue;
        paddingHorizontal?: FlexValue;
        paddingVertical?: FlexValue;
        padding?: FlexValue;
        borderLeftWidth?: number;
        borderRightWidth?: number;
        borderTopWidth?: number;
        borderBottomWidth?: number;
        borderStartWidth?: number;
        borderEndWidth?: number;
        borderWidth?: number;
        left?: FlexValue;
        right?: FlexValue;
        top?: FlexValue;
        bottom?: FlexValue;
        start?: FlexValue;
        end?: FlexValue;
        width?: FlexValue;
        height?: FlexValue;
        minWidth?: FlexValue;
        minHeight?: FlexValue;
        maxWidth?: FlexValue;
        maxHeight?: FlexValue;
        aspectRatio?: number;
    }
    export {};
}

declare module 'doric/lib/src/util/jsx' {
    import { Group, View } from "doric/lib/src/ui/view";
    import { ClassType } from "doric/lib/src/util/types";
    export namespace jsx {
        function createElement<T extends View>(constructor: ClassType<T>, config: Partial<T> | null, ...children: any[]): any[] | T;
        class Fragment extends Group {
        }
    }
    global {
        namespace JSX {
            interface Element extends View {
            }
            interface ElementClass extends View {
            }
            interface ElementAttributesProperty {
                props: {};
            }
            interface ElementChildrenAttribute {
                innerElement: any;
            }
            interface IntrinsicElements {
            }
        }
    }
}

declare module 'doric/lib/src/util/resource' {
    import { Modeling } from "doric/lib/src/util/types";
    export abstract class Resource implements Modeling {
            type: string;
            identifier: string;
            resId: string;
            constructor(type: string, identifier: string);
            toModel(): {
                    resId: string;
                    type: string;
                    identifier: string;
            };
    }
    export class LocalResource extends Resource {
            constructor(path: string);
    }
    export class RemoteResource extends Resource {
            constructor(url: string);
    }
    export class Base64Resource extends Resource {
            constructor(content: string);
    }
    /**
        * Resources belong to assets dir.
        */
    export class AssetsResource extends Resource {
            constructor(content: string);
    }
    export class AndroidResource extends Resource {
    }
    export class iOSResource extends Resource {
    }
    /**
        * This is for android platform
        */
    export class DrawableResource extends AndroidResource {
            constructor(name: string);
    }
    export class RawResource extends AndroidResource {
            constructor(name: string);
    }
    export class AndroidAssetsResource extends AndroidResource {
            constructor(path: string);
    }
    /**
        * This is for iOS platform
        */
    export class MainBundleResource extends iOSResource {
            constructor(fileName: string);
    }
    export class BundleResource extends iOSResource {
            constructor(bundleName: string, fileName: string);
    }
    export class ArrayBufferResource extends Resource {
            data: ArrayBuffer;
            constructor(data: ArrayBuffer);
            toModel(): {
                    resId: string;
                    type: string;
                    identifier: string;
            };
    }
}

declare module 'doric/lib/src/pattern/candies' {
    export function take<T>(target: T): (block: (p: T) => void) => void;
    export function takeNonNull<T, R>(target?: T): (block: (p: T) => R) => R | undefined;
    export function takeNull<T, R>(target?: T): (block: () => R) => R | undefined;
    export function takeLet<T, R>(target: T): (block: (p: T) => R | undefined) => R | undefined;
    export function takeAlso<T>(target: T): (block: (p: T) => void) => T;
    export function takeIf<T>(target: T): (predicate: (t: T) => boolean) => T | undefined;
    export function takeUnless<T>(target: T): (predicate: (t: T) => boolean) => T | undefined;
    export function repeat(action: (count: number) => void): (times: number) => void;
}

declare module 'doric/lib/src/pattern/provider' {
    export type Observer<T> = (v: T) => void;
    export type Updater<T> = (v: T) => T;
    export interface IObservable<T> {
        addObserver(observer: Observer<T | undefined>): void;
        removeObserver(observer: Observer<T | undefined>): void;
        update(updater: Updater<T | undefined>): void;
    }
    export class Observable<M> implements IObservable<M> {
        constructor(provider: IProvider, clz: {
            new (...args: any[]): M;
        });
        addObserver(observer: Observer<M | undefined>): void;
        removeObserver(observer: Observer<M | undefined>): void;
        update(updater: Updater<M | undefined>): void;
    }
    export interface IProvider {
        provide(obj: Object): void;
        acquire<T>(clz: {
            new (...args: any[]): T;
        }): T | undefined;
        remove<T>(clz: {
            new (...args: any[]): T;
        }): void;
        clear(): void;
        observe<T>(clz: {
            new (...args: any[]): T;
        }): Observable<T>;
    }
    export class Provider implements IProvider {
        provide(obj: Object): void;
        acquire<T>(clz: {
            new (...args: any[]): T;
        }): T | undefined;
        remove<T>(clz: new (...args: any[]) => T): void;
        clear(): void;
        observe<T>(clz: new (...args: any[]) => T): Observable<T>;
    }
}

declare module 'doric/lib/src/pattern/mvvm' {
    import { Group } from "doric/lib/src/ui/view";
    import { Panel } from "doric/lib/src/ui/panel";
    import { BridgeContext } from "doric/lib/src/runtime/global";
    import { ClassType } from "doric/lib/src/util/types";
    export abstract class ViewHolder {
        abstract build(root: Group): void;
    }
    export type Setter<M> = (state: M) => void;
    export abstract class ViewModel<M extends Object, V extends ViewHolder> {
        context: BridgeContext;
        constructor(obj: M, v: V);
        getState(): M;
        getViewHolder(): V;
        updateState(setter: Setter<M>): void;
        attach(view: Group): void;
        abstract onAttached(state: M, vh: V): void;
        abstract onBind(state: M, vh: V): void;
    }
    export abstract class VMPanel<M extends Object, V extends ViewHolder> extends Panel {
        abstract getViewModelClass(): ClassType<ViewModel<M, V>>;
        abstract getState(): M;
        abstract getViewHolderClass(): ClassType<V>;
        getViewModel(): ViewModel<M, V> | undefined;
        build(root: Group): void;
    }
}

declare module 'doric/lib/src/pattern/modular' {
    import { Panel } from "doric/lib/src/ui/panel";
    import { Group } from "doric/lib/src/ui/view";
    import { ClassType } from "doric/lib/src/util/types";
    import { ViewHolder, ViewModel } from "doric/lib/src/pattern/mvvm";
    import { Provider } from "doric/lib/src/pattern/provider";
    export abstract class Module extends Panel {
            superPanel?: ModularPanel;
            __provider?: Provider;
            get provider(): Provider | undefined;
            set provider(provider: Provider | undefined);
            mount(): void;
            unmount(): void;
            get mounted(): boolean;
            /**
                * Dispatch message to other modules.
                * @param message which is sent out
                */
            dispatchMessage(message: any): void;
            /**
                * Dispatched messages can be received by override this method.
                * @param message recevied message
                */
            onMessage(message: any): void;
            /**
                * Called when this module is mounted
                */
            onMounted(): void;
            /**
                * Called when this module is unmounted
                */
            onUnmounted(): void;
    }
    export abstract class VMModule<M extends Object, V extends ViewHolder> extends Module {
            abstract getViewModelClass(): ClassType<ViewModel<M, V>>;
            abstract getState(): M;
            abstract getViewHolderClass(): ClassType<V>;
            getViewModel(): ViewModel<M, V> | undefined;
            build(root: Group): void;
    }
    export abstract class ModularPanel extends Module {
            constructor();
            /**
                * @returns Class list of current submodules
                */
            abstract setupModules(): ClassType<Panel>[];
            /**
                * @param root Current module's rootview
                * @returns provided for submodules as their rootview
                */
            abstract setupShelf(root: Group): Group;
            dispatchMessage(message: any): void;
            get mountedModules(): Panel[];
            onMessage(message: any): void;
            onStructureChanged(module: Module, mounted: boolean): void;
            build(root: Group): void;
            onCreate(): void;
            onDestroy(): void;
            onShow(): void;
            onHidden(): void;
            onRenderFinished(): void;
    }
}

declare module '*.png' {
    const value: any;
    export default value;
}