declare module "doric" {
	// Generated by dts-bundle-generator v6.13.0
	
	export interface Modeling {
		toModel(): Model;
	}
	export function obj2Model(obj: Model, convertor: (v: Function) => string): Model;
	export type _M = string | number | boolean | Modeling | {
		[index: string]: Model;
	} | undefined;
	export type Model = _M | Array<_M>;
	export type Binder<T> = (v: T) => void;
	export class Mutable<T> {
		private val;
		private binders;
		get: () => T;
		set: (v: T) => void;
		private constructor();
		bind(binder: Binder<T>): void;
		static of<E>(v: E): Mutable<E>;
	}
	export type ClassType<T> = new (...args: any) => T;
	/**
	 *  Store color as format AARRGGBB or RRGGBB
	 */
	export class Color implements Modeling {
		static BLACK: Color;
		static DKGRAY: Color;
		static GRAY: Color;
		static LTGRAY: Color;
		static WHITE: Color;
		static RED: Color;
		static GREEN: Color;
		static BLUE: Color;
		static YELLOW: Color;
		static CYAN: Color;
		static MAGENTA: Color;
		static TRANSPARENT: Color;
		_value: number;
		constructor(v: number);
		static parse(str: string): Color;
		static safeParse(str: string, defVal?: Color): Color;
		alpha(v: number): Color;
		toModel(): number;
	}
	export enum GradientOrientation {
		/** draw the gradient from the top to the bottom */
		TOP_BOTTOM = 0,
		/** draw the gradient from the top-right to the bottom-left */
		TR_BL = 1,
		/** draw the gradient from the right to the left */
		RIGHT_LEFT = 2,
		/** draw the gradient from the bottom-right to the top-left */
		BR_TL = 3,
		/** draw the gradient from the bottom to the top */
		BOTTOM_TOP = 4,
		/** draw the gradient from the bottom-left to the top-right */
		BL_TR = 5,
		/** draw the gradient from the left to the right */
		LEFT_RIGHT = 6,
		/** draw the gradient from the top-left to the bottom-right */
		TL_BR = 7
	}
	export interface GradientColor {
		start?: Color;
		end?: Color;
		colors?: Array<Color>;
		locations?: Array<Number>;
		orientation: GradientOrientation;
	}
	export const LEFT: number;
	export const RIGHT: number;
	export const TOP: number;
	export const BOTTOM: number;
	export const CENTER_X: number;
	export const CENTER_Y: number;
	export const CENTER: number;
	export class Gravity implements Modeling {
		val: number;
		left(): Gravity;
		right(): Gravity;
		top(): Gravity;
		bottom(): Gravity;
		center(): Gravity;
		centerX(): Gravity;
		centerY(): Gravity;
		toModel(): number;
		private static origin;
		static Center: Gravity;
		static CenterX: Gravity;
		static CenterY: Gravity;
		static Left: Gravity;
		static Right: Gravity;
		static Top: Gravity;
		static Bottom: Gravity;
	}
	export function gravity(): Gravity;
	export enum LayoutSpec {
		/**
		 * Depends on what's been set on width or height.
		*/
		JUST = 0,
		/**
		 * Depends on it's content.
		 */
		FIT = 1,
		/**
		 * Extend as much as parent let it take.
		 */
		MOST = 2
	}
	export interface LayoutConfig {
		widthSpec?: LayoutSpec;
		heightSpec?: LayoutSpec;
		margin?: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
		};
		alignment?: Gravity;
		weight?: number;
		maxWidth?: number;
		maxHeight?: number;
		minWidth?: number;
		minHeight?: number;
	}
	export class LayoutConfigImpl implements LayoutConfig, Modeling {
		widthSpec?: LayoutSpec;
		heightSpec?: LayoutSpec;
		margin?: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
		};
		alignment?: Gravity;
		weight?: number;
		maxWidth?: number;
		maxHeight?: number;
		minWidth?: number;
		minHeight?: number;
		fit(): this;
		fitWidth(): this;
		fitHeight(): this;
		most(): this;
		mostWidth(): this;
		mostHeight(): this;
		just(): this;
		justWidth(): this;
		justHeight(): this;
		configWidth(w: LayoutSpec): this;
		configHeight(h: LayoutSpec): this;
		configMargin(m: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
		}): this;
		configAlignment(a: Gravity): this;
		configWeight(w: number): this;
		configMaxWidth(v: number): this;
		configMaxHeight(v: number): this;
		configMinWidth(v: number): this;
		configMinHeight(v: number): this;
		toModel(): {
			widthSpec: LayoutSpec | undefined;
			heightSpec: LayoutSpec | undefined;
			margin: {
				left?: number | undefined;
				right?: number | undefined;
				top?: number | undefined;
				bottom?: number | undefined;
			} | undefined;
			alignment: number | undefined;
			weight: number | undefined;
			minWidth: number | undefined;
			maxWidth: number | undefined;
			minHeight: number | undefined;
			maxHeight: number | undefined;
		};
	}
	export function layoutConfig(): LayoutConfigImpl;
	export type AnimatedKey = "translationX" | "translationY" | "scaleX" | "scaleY" | "rotation" | "pivotX" | "pivotY" | "rotationX" | "rotationY" | "backgroundColor" | "alpha";
	export enum RepeatMode {
		RESTART = 1,
		REVERSE = 2
	}
	export interface IAnimation extends Modeling {
		duration: number;
		delay?: number;
		id: string;
	}
	export interface Changeable {
		fromValue: number;
		toValue: number;
		key: AnimatedKey;
		repeatCount?: number;
		repeatMode?: RepeatMode;
		keyFrames?: {
			percent: number;
			value: number;
		}[];
	}
	export enum FillMode {
		/**
		 * The receiver is removed from the presentation when the animation is completed.
		 */
		Removed = 0,
		/**
		 * The receiver remains visible in its final state when the animation is completed.
		 */
		Forward = 1,
		/**
		 * The receiver clamps values before zero to zero when the animation is completed.
		 */
		Backward = 2,
		/**
		 * The receiver clamps values at both ends of the object’s time space
		 */
		Both = 3
	}
	export enum TimingFunction {
		/**
		 * The system default timing function. Use this function to ensure that the timing of your animations matches that of most system animations.
		 */
		Default = 0,
		/**
		 * Linear pacing, which causes an animation to occur evenly over its duration.
		 */
		Linear = 1,
		/**
		 * Ease-in pacing, which causes an animation to begin slowly and then speed up as it progresses.
		 */
		EaseIn = 2,
		/**
		 * Ease-out pacing, which causes an animation to begin quickly and then slow as it progresses.
		 */
		EaseOut = 3,
		/**
		 * Ease-in-ease-out pacing, which causes an animation to begin slowly, accelerate through the middle of its duration, and then slow again before completing.
		 */
		EaseInEaseOut = 4
	} abstract class Animation implements IAnimation {
		changeables: Map<AnimatedKey, Changeable>;
		duration: number;
		repeatCount?: number;
		repeatMode?: RepeatMode;
		delay?: number;
		fillMode: FillMode;
		timingFunction?: TimingFunction;
		id: string;
		toModel(): {
			type: string;
			delay: number | undefined;
			duration: number;
			changeables: {
				key: AnimatedKey;
				fromValue: number;
				toValue: number;
				keyFrames: {
					percent: number;
					value: number;
				}[] | undefined;
			}[];
			repeatCount: number | undefined;
			repeatMode: RepeatMode | undefined;
			fillMode: FillMode;
			timingFunction: TimingFunction | undefined;
			id: string;
		};
	}
	export class ScaleAnimation extends Animation {
		private scaleXChangeable;
		private scaleYChangeable;
		constructor();
		set xKeyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
		set yKeyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
		set fromScaleX(v: number);
		get fromScaleX(): number;
		set toScaleX(v: number);
		get toScaleX(): number;
		set fromScaleY(v: number);
		get fromScaleY(): number;
		set toScaleY(v: number);
		get toScaleY(): number;
	}
	export class TranslationAnimation extends Animation {
		private translationXChangeable;
		private translationYChangeable;
		constructor();
		set xKeyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
		set yKeyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
		set fromTranslationX(v: number);
		get fromTranslationX(): number;
		set toTranslationX(v: number);
		get toTranslationX(): number;
		set fromTranslationY(v: number);
		get fromTranslationY(): number;
		set toTranslationY(v: number);
		get toTranslationY(): number;
	}
	/**
	 * Rotation range is [0..2]
	 */
	export class RotationAnimation extends Animation {
		private rotationChaneable;
		constructor();
		set fromRotation(v: number);
		get fromRotation(): number;
		set toRotation(v: number);
		get toRotation(): number;
		set keyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
	}
	/**
	 * Rotation range is [0..2]
	 */
	export class RotationXAnimation extends Animation {
		private rotationChaneable;
		constructor();
		set fromRotation(v: number);
		get fromRotation(): number;
		set toRotation(v: number);
		get toRotation(): number;
		set keyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
	}
	/**
	 * Rotation range is [0..2]
	 */
	export class RotationYAnimation extends Animation {
		private rotationChaneable;
		constructor();
		set fromRotation(v: number);
		get fromRotation(): number;
		set toRotation(v: number);
		get toRotation(): number;
		set keyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
	}
	export class BackgroundColorAnimation extends Animation {
		private backgroundColorChangeable;
		constructor();
		set fromColor(color: Color);
		get fromColor(): Color;
		set toColor(v: Color);
		get toColor(): Color;
		set keyFrames(keyFrames: {
			percent: number;
			value: Color;
		}[]);
	}
	/**
	 * Alpha range is [0..1]
	 */
	export class AlphaAnimation extends Animation {
		private opacityChangeable;
		constructor();
		set from(v: number);
		get from(): number;
		set to(v: number);
		get to(): number;
		set keyFrames(keyFrames: {
			percent: number;
			value: number;
		}[]);
	}
	export class AnimationSet implements IAnimation {
		private animations;
		private _duration;
		delay?: number;
		id: string;
		addAnimation(anim: IAnimation): void;
		get duration(): number;
		set duration(v: number);
		toModel(): {
			animations: Model;
			delay: number | undefined;
			id: string;
		};
	} enum ValueType {
		Undefined = 0,
		Point = 1,
		Percent = 2,
		Auto = 3
	}
	export class FlexTypedValue implements Modeling {
		type: ValueType;
		value: number;
		constructor(type: ValueType);
		static Auto: FlexTypedValue;
		static percent(v: number): FlexTypedValue;
		static point(v: number): FlexTypedValue;
		toModel(): {
			type: ValueType;
			value: number;
		};
	}
	export enum FlexDirection {
		COLUMN = 0,
		COLUMN_REVERSE = 1,
		ROW = 2,
		ROW_REVERSE = 3
	}
	export enum Align {
		AUTO = 0,
		FLEX_START = 1,
		CENTER = 2,
		FLEX_END = 3,
		STRETCH = 4,
		BASELINE = 5,
		SPACE_BETWEEN = 6,
		SPACE_AROUND = 7
	}
	export enum Justify {
		FLEX_START = 0,
		CENTER = 1,
		FLEX_END = 2,
		SPACE_BETWEEN = 3,
		SPACE_AROUND = 4,
		SPACE_EVENLY = 5
	}
	export enum Direction {
		INHERIT = 0,
		LTR = 1,
		RTL = 2
	}
	export enum PositionType {
		RELATIVE = 0,
		ABSOLUTE = 1
	}
	export enum Wrap {
		NO_WRAP = 0,
		WRAP = 1,
		WRAP_REVERSE = 2
	}
	export enum OverFlow {
		VISIBLE = 0,
		HIDDEN = 1,
		SCROLL = 2
	}
	export enum Display {
		FLEX = 0,
		NONE = 1
	}
	export type FlexValue = FlexTypedValue | number;
	export interface FlexConfig {
		direction?: Direction;
		flexDirection?: FlexDirection;
		justifyContent?: Justify;
		alignContent?: Align;
		alignItems?: Align;
		alignSelf?: Align;
		positionType?: PositionType;
		flexWrap?: Wrap;
		overFlow?: OverFlow;
		display?: Display;
		flex?: number;
		flexGrow?: number;
		flexShrink?: number;
		flexBasis?: FlexValue;
		marginLeft?: FlexValue;
		marginRight?: FlexValue;
		marginTop?: FlexValue;
		marginBottom?: FlexValue;
		marginStart?: FlexValue;
		marginEnd?: FlexValue;
		marginHorizontal?: FlexValue;
		marginVertical?: FlexValue;
		margin?: FlexValue;
		paddingLeft?: FlexValue;
		paddingRight?: FlexValue;
		paddingTop?: FlexValue;
		paddingBottom?: FlexValue;
		paddingStart?: FlexValue;
		paddingEnd?: FlexValue;
		paddingHorizontal?: FlexValue;
		paddingVertical?: FlexValue;
		padding?: FlexValue;
		borderLeftWidth?: number;
		borderRightWidth?: number;
		borderTopWidth?: number;
		borderBottomWidth?: number;
		borderStartWidth?: number;
		borderEndWidth?: number;
		borderWidth?: number;
		left?: FlexValue;
		right?: FlexValue;
		top?: FlexValue;
		bottom?: FlexValue;
		start?: FlexValue;
		end?: FlexValue;
		width?: FlexValue;
		height?: FlexValue;
		minWidth?: FlexValue;
		minHeight?: FlexValue;
		maxWidth?: FlexValue;
		maxHeight?: FlexValue;
		aspectRatio?: number;
	}
	export function Property(target: Object, propKey: string): void;
	export function InconsistProperty(target: Object, propKey: string): void;
	export function ViewComponent(constructor: ClassType<any>): void;
	export type NativeViewModel = {
		id: string;
		type: string;
		props: {
			[index: string]: Model;
		};
	};
	export type RefType<T> = T extends Ref<infer R> ? R : never;
	export class Ref<T extends View> {
		private view?;
		set current(v: T);
		get current(): T;
		apply(config: Partial<RefType<this>>): void;
	}
	export function createRef<T extends View>(): Ref<T>;
	export abstract class View implements Modeling {
		width: number;
		height: number;
		x: number;
		y: number;
		backgroundColor?: Color | GradientColor;
		corners?: number | {
			leftTop?: number;
			rightTop?: number;
			leftBottom?: number;
			rightBottom?: number;
		};
		border?: {
			width: number;
			color: Color;
		};
		shadow?: {
			color: Color;
			opacity: number;
			radius: number;
			offsetX: number;
			offsetY: number;
		};
		/**
		 * float [0,..1]
		 */
		alpha?: number;
		hidden?: boolean;
		viewId: string;
		tag?: string;
		layoutConfig?: LayoutConfig;
		onClick?: Function;
		superview?: Superview;
		callbacks: Map<String, Function>;
		callback2Id(f: Function): string;
		private id2Callback;
		findViewByTag(tag: string): View | undefined;
		constructor();
		/** Anchor start*/
		get left(): number;
		set left(v: number);
		get right(): number;
		set right(v: number);
		get top(): number;
		set top(v: number);
		get bottom(): number;
		set bottom(v: number);
		get centerX(): number;
		get centerY(): number;
		set centerX(v: number);
		set centerY(v: number);
		/** Anchor end*/
		private __dirty_props__;
		get dirtyProps(): {
			[index: string]: Model;
		};
		nativeViewModel: NativeViewModel;
		viewType(): any;
		onPropertyChanged(propKey: string, oldV: Model, newV: Model): void;
		clean(): void;
		isDirty(): boolean;
		responseCallback(id: string, ...args: any): any;
		toModel(): NativeViewModel;
		let(block: (it: this) => void): void;
		also(block: (it: this) => void): this;
		apply(config: Partial<this>): this;
		in(group: Group): this;
		nativeChannel(context: BridgeContext, name: string): (args?: any) => Promise<any>;
		getWidth(context: BridgeContext): Promise<number>;
		getHeight(context: BridgeContext): Promise<number>;
		getX(context: BridgeContext): Promise<number>;
		getY(context: BridgeContext): Promise<number>;
		getLocationOnScreen(context: BridgeContext): Promise<{
			x: number;
			y: number;
		}>;
		/**++++++++++transform++++++++++*/
		translationX?: number;
		translationY?: number;
		/**
		 * float [0,..1]
		 */
		scaleX?: number;
		scaleY?: number;
		pivotX?: number;
		pivotY?: number;
		/**
		 * rotation*PI
		 * In Z
		 */
		rotation?: number;
		/**
		 * rotation*PI
		 * In X
		 */
		rotationX?: number;
		/**
		 * rotation*PI
		 * In Y
		 */
		rotationY?: number;
		/**
		 * Determines the distance between the z=0 plane and the user in order to give a 3D-positioned element some perspective.
		 * Default is 200
		 */
		perspective?: number;
		/**----------transform----------*/
		/**
		 * Only affected when its superview or itself is FlexLayout.
		 */
		flexConfig?: FlexConfig;
		set props(props: Partial<this>);
		set parent(v: Group);
		private _ref?;
		set ref(ref: Ref<this>);
		doAnimation(context: BridgeContext, animation: IAnimation): Promise<void>;
		clearAnimation(context: BridgeContext, animation: IAnimation): Promise<void>;
		cancelAnimation(context: BridgeContext, animation: IAnimation): Promise<void>;
		static isViewClass(): boolean;
	}
	export abstract class Superview extends View {
		subviewById(id: string): View | undefined;
		findViewByTag(tag: string): View | undefined;
		private findViewTraversal;
		abstract allSubviews(): Iterable<View>;
		isDirty(): boolean;
		clean(): void;
		toModel(): NativeViewModel;
	}
	export type ViewArray = View[];
	export type ViewFragment = View | ViewArray | undefined | null;
	export abstract class Group extends Superview implements JSX.ElementChildrenAttribute {
		padding?: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
		};
		readonly children: View[];
		allSubviews(): View[];
		addChild(view: View): void;
		removeChild(view: View): void;
		removeAllChildren(): void;
		private addInnerElement;
		set innerElement(e: View | ViewFragment | ViewFragment[] | undefined | null);
	}
	export class Stack extends Group {
	}
	export class Root extends Stack {
	} class LinearLayout extends Group {
		space?: number;
		gravity?: Gravity;
	}
	export class VLayout extends LinearLayout {
	}
	export class HLayout extends LinearLayout {
	}
	export function stack(views: View[], config?: Partial<Stack>): Stack;
	export function hlayout(views: View[], config?: Partial<HLayout>): HLayout;
	export function vlayout(views: View[], config?: Partial<VLayout>): VLayout;
	export class FlexLayout extends Group {
	}
	export function flexlayout(views: View[], config?: Partial<FlexLayout>): FlexLayout;
	export function NativeCall(target: Panel, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor;
	export abstract class Panel {
		private destroyed;
		context: BridgeContext;
		onCreate(): void;
		onDestroy(): void;
		onShow(): void;
		onHidden(): void;
		onEnvChanged(): void;
		/**
		 * Build view of the current Panel
		 * This could be called any times at any time when necessary.
		 * @param rootView root view of this panel
		 */
		abstract build(rootView: Group): void;
		private __data__?;
		private __root__;
		private headviews;
		private onRenderFinishedCallback;
		private __rendering__;
		private callingRenderFinishedCallback;
		addHeadView(type: string, v: View): void;
		allHeadViews(): IterableIterator<Map<string, View>>;
		removeHeadView(type: string, v: View | string): void;
		clearHeadViews(type: string): void;
		getRootView(): Root;
		getInitData(): object | undefined;
		private __init__;
		private __onCreate__;
		private __onDestroy__;
		private __onShow__;
		private __onHidden__;
		private __build__;
		private __onEnvChanged__;
		private __response__;
		private retrospectView;
		private snapshotEnabled;
		private renderSnapshots;
		private __renderSnapshotDepth__;
		private __restoreRenderSnapshot__;
		private __enableSnapshot__;
		private nativeRender;
		private hookBeforeNativeCall;
		private hookAfterNativeCall;
		private __fetchEffectiveData__;
		onRenderFinished(): void;
		addOnRenderFinishedCallback(cb: () => void): void;
	}
	export type BridgeContext = {
		/**
		 * The identify of current context
		 */
		id: string;
		/**
		 * In this case,It's current panel
		 */
		entity: any;
		/**
		 * call native plugin
		 * @param namespace
		 * @param method
		 * @param args
		 */
		callNative(namespace: string, method: string, args?: any): Promise<any>;
		/**
		 * Transform function to functionId as string
		 * @param func
		 */
		function2Id(func: Function): string;
		/**
		 * Remove transformed functions
		 * @param funcId
		 */
		removeFuncById(funcId: string): void;
	}; global {
		const context: BridgeContext;
		const Environment: {
			platform: "Android" | "iOS" | "Qt" | "web";
			platformVersion: string;
			appName: string;
			appVersion: string;
			libVersion: string;
			screenWidth: number;
			screenHeight: number;
			screenScale: number;
			statusBarHeight: number;
			hasNotch: boolean;
			/**
			 * ex:Apple or Google
			 */
			deviceBrand: string;
			/**
			 * ex: iPhone12,5 or pixel 3
			 */
			deviceModel: string;
			/**
			 * The language code for current locale
			 */
			localeLanguage: string;
			/**
			 * The country/region code for current locale
			 */
			localeCountry: string;
			[index: string]: number | string | boolean | object | undefined;
		};
		function Entry(constructor: ClassType<Panel>): void;
		function Entry(exports: ClassType<Panel>[]): (constructor: ClassType<Panel>) => void;
	}
	export abstract class Resource implements Modeling {
		type: string;
		identifier: string;
		resId: string;
		constructor(type: string, identifier: string);
		toModel(): {
			resId: string;
			type: string;
			identifier: string;
		};
	}
	export class LocalResource extends Resource {
		constructor(path: string);
	}
	export class RemoteResource extends Resource {
		constructor(url: string);
	}
	export class Base64Resource extends Resource {
		constructor(content: string);
	}
	/**
	 * Resources belong to assets dir.
	 */
	export class AssetsResource extends Resource {
		constructor(content: string);
	}
	export class AndroidResource extends Resource {
	}
	export class iOSResource extends Resource {
	}
	/**
	 * This is for android platform
	 */
	export class DrawableResource extends AndroidResource {
		constructor(name: string);
	}
	export class RawResource extends AndroidResource {
		constructor(name: string);
	}
	export class AndroidAssetsResource extends AndroidResource {
		constructor(path: string);
	}
	/**
	 * This is for iOS platform
	 */
	export class MainBundleResource extends iOSResource {
		constructor(fileName: string);
	}
	export class BundleResource extends iOSResource {
		constructor(bundleName: string, fileName: string);
	}
	export class ArrayBufferResource extends Resource {
		data: ArrayBuffer;
		constructor(data: ArrayBuffer);
		toModel(): {
			resId: string;
			type: string;
			identifier: string;
		};
	}
	export enum TruncateAt {
		End = 0,
		Middle = 1,
		Start = 2,
		Clip = 3
	}
	export class Text extends View implements JSX.ElementChildrenAttribute {
		text?: string;
		textColor?: Color | GradientColor;
		textSize?: number;
		maxLines?: number;
		textAlignment?: Gravity;
		fontStyle?: "normal" | "bold" | "italic" | "bold_italic";
		font?: string | Resource;
		maxWidth?: number;
		maxHeight?: number;
		lineSpacing?: number;
		strikethrough?: boolean;
		underline?: boolean;
		htmlText?: string;
		truncateAt?: TruncateAt;
		padding?: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
		};
		set innerElement(e: string);
	}
	export function text(config: Partial<Text>): Text;
	export enum ScaleType {
		ScaleToFill = 0,
		ScaleAspectFit = 1,
		ScaleAspectFill = 2,
		Tile = 3,
		ScaleAspectFitStart = 4,
		ScaleAspectFitEnd = 5
	}
	export class Image extends View {
		/**
		 * Set pixels for image directly
		*/
		imagePixels?: {
			width: number;
			height: number;
			pixels: ArrayBuffer;
		};
		/**
		 * This could be loaded by customized resource loader
		*/
		image?: Resource;
		imageUrl?: string;
		/**
		 * Read image from local file system.
		*/
		imageFilePath?: string;
		/**
		 * Read image from local path
		 * For android,it based on assets dir.
		 * For iOS,it based on main bundle dir.
		*/
		imagePath?: string;
		/**
		 * Read image from resource
		 * For android,it will try to read from drawable.
		 * For iOS,it will try to read from Image.Assets.
		 */
		imageRes?: string;
		imageBase64?: string;
		scaleType?: ScaleType;
		isBlur?: boolean;
		/**
		 * Display while image is loading
		 * Local file name
		 */
		placeHolderImage?: string;
		placeHolderImageBase64?: string;
		/**
		 * Display while image is loading
		 * Color
		 * This priority is lower than placeHolderImage
		 */
		placeHolderColor?: Color;
		/**
		 * Display while image is failed to load
		 * It can be file name in local path
		 */
		errorImage?: string;
		errorImageBase64?: string;
		/**
		 * Display while image is failed to load
		 * Color
		 * This priority is lower than errorImage
		 */
		errorColor?: Color;
		loadCallback?: (image: {
			width: number;
			height: number;
			animated: boolean;
		} | undefined) => void;
		/**
		 * Default is Environment.screenScale.
		 */
		imageScale?: number;
		/**
		 * Unit in pixel
		 */
		stretchInset?: {
			left: number;
			top: number;
			right: number;
			bottom: number;
		};
		/**
		 * Called if loaded image is animated and played end.
		 */
		onAnimationEnd?: () => void;
		isAnimating(context: BridgeContext): Promise<boolean>;
		startAnimating(context: BridgeContext): Promise<any>;
		stopAnimating(context: BridgeContext): Promise<any>;
		getImageInfo(context: BridgeContext): Promise<{
			width: number;
			height: number;
			mimeType: string;
		}>;
		getImagePixels(context: BridgeContext): Promise<ArrayBuffer>;
		setImagePixels(context: BridgeContext, image: {
			width: number;
			height: number;
			pixels: ArrayBuffer;
		}): Promise<void>;
	}
	export function image(config: Partial<Image>): Image;
	export class ListItem extends Stack {
		/**
		 * Set to reuse native view
		 */
		identifier?: string;
		actions?: {
			title: string;
			backgroundColor?: Color;
			callback: () => void;
		}[];
	}
	export class List extends Superview {
		private cachedViews;
		allSubviews(): ListItem[];
		itemCount: number;
		renderItem: (index: number) => ListItem;
		batchCount: number;
		onLoadMore?: () => void;
		loadMore?: boolean;
		loadMoreView?: ListItem;
		onScroll?: (offset: {
			x: number;
			y: number;
		}) => void;
		onScrollEnd?: (offset: {
			x: number;
			y: number;
		}) => void;
		scrolledPosition?: number;
		scrollable?: boolean;
		/**
		 * Take effect only on iOS
		 */
		bounces?: boolean;
		/**
		 * Take effect only on iOS
		 */
		scrollsToTop?: boolean;
		canDrag?: boolean;
		/**
		 * @param from
		 * @returns Returns the item of index which can dragged or not.
		 */
		itemCanDrag?: (from: number) => boolean;
		/**
		 * @param from
		 * @returns Returns an array of index which can not be swap during dragging.
		 */
		beforeDragging?: (from: number) => (Array<number> | void);
		onDragging?: (from: number, to: number) => void;
		onDragged?: (from: number, to: number) => void;
		preloadItemCount?: number;
		/**
		 * @param {number} config.topOffset - 目标位置cell的顶部偏移量
		 */
		scrollToItem(context: BridgeContext, index: number, config?: {
			animated?: boolean;
			topOffset?: number;
		}): Promise<any>;
		/**
		 * @param context
		 * @returns Returns array of visible view's index.
		 */
		findVisibleItems(context: BridgeContext): Promise<number[]>;
		/**
		 * @param context
		 * @returns Returns array of completely visible view's index.
		 */
		findCompletelyVisibleItems(context: BridgeContext): Promise<number[]>;
		/**
		 * Reload all list items.
		 * @param context
		 * @returns
		 */
		reload(context: BridgeContext): Promise<void>;
		reset(): void;
		private getItem;
		private renderBunchedItems;
		toModel(): NativeViewModel;
	}
	export function list(config: Partial<List>): List;
	export function listItem(item: View | View[], config?: Partial<ListItem>): ListItem;
	export class SlideItem extends Stack {
		/**
		 * Set to reuse native view
		 */
		identifier?: string;
	}
	export class Slider extends Superview {
		private cachedViews;
		allSubviews(): IterableIterator<SlideItem>;
		itemCount: number;
		renderPage: (index: number) => SlideItem;
		batchCount: number;
		onPageSlided?: (index: number) => void;
		loop?: boolean;
		scrollable?: boolean;
		/**
		 * Take effect only on iOS
		 */
		bounces?: boolean;
		/**
		* Take effect only on iOS
		*/
		scrollsToTop?: boolean;
		/**
		 * Set the effect when sliding
		 * ZoomOut is currently supported
		 */
		slideStyle?: "zoomOut" | {
			type: "zoomOut";
			minScale: number;
			maxScale: number;
		} | {
			type: "gallery";
			itemWidth: number;
			minScale: number;
			minAlpha: number;
		};
		slidePosition?: number;
		/**
		 * Reload all list items.
		 * @param context
		 * @returns
		 */
		reload(context: BridgeContext): Promise<void>;
		reset(): void;
		private getItem;
		private renderBunchedItems;
		slidePage(context: BridgeContext, page: number, smooth?: boolean): Promise<any>;
		getSlidedPage(context: BridgeContext): Promise<number>;
	}
	export function slider(config: Partial<Slider>): Slider;
	export function slideItem(item: View | View[], config?: Partial<SlideItem>): SlideItem;
	export function scroller(content: View, config?: Partial<Scroller>): Scroller;
	export class Scroller extends Superview implements JSX.ElementChildrenAttribute {
		content: View;
		contentOffset?: {
			x: number;
			y: number;
		};
		onScroll?: (offset: {
			x: number;
			y: number;
		}) => void;
		onScrollEnd?: (offset: {
			x: number;
			y: number;
		}) => void;
		scrollable?: boolean;
		/**
		 * Take effect only on iOS
		 */
		bounces?: boolean;
		/**
		 * Take effect only on iOS
		 */
		scrollsToTop?: boolean;
		allSubviews(): View[];
		toModel(): NativeViewModel;
		scrollTo(context: BridgeContext, offset: {
			x: number;
			y: number;
		}, animated?: boolean): Promise<any>;
		scrollBy(context: BridgeContext, offset: {
			x: number;
			y: number;
		}, animated?: boolean): Promise<any>;
		set innerElement(e: View);
	}
	export class Refreshable extends Superview implements JSX.ElementChildrenAttribute {
		content: View;
		header?: View;
		onRefresh?: () => void;
		allSubviews(): View[];
		setRefreshable(context: BridgeContext, refreshable: boolean): Promise<any>;
		setRefreshing(context: BridgeContext, refreshing: boolean): Promise<any>;
		isRefreshable(context: BridgeContext): Promise<boolean>;
		isRefreshing(context: BridgeContext): Promise<boolean>;
		toModel(): NativeViewModel;
		set innerElement(e: View | [
			View,
			View
		]);
	}
	export function refreshable(config: Partial<Refreshable>): Refreshable;
	export interface IPullable {
		startAnimation(): void;
		stopAnimation(): void;
		setPullingDistance(distance: number): void;
	}
	export function pullable(v: View, config: IPullable): View;
	export class FlowLayoutItem extends Stack {
		/**
		* Set to reuse native view
		*/
		identifier?: string;
		/**
		 * When set to true, the item will layout using all span area.
		 * LoadMoreView is default to true.
		 */
		fullSpan?: boolean;
	}
	export class FlowLayout extends Superview {
		private cachedViews;
		allSubviews(): FlowLayoutItem[];
		columnCount: number;
		columnSpace?: number;
		rowSpace?: number;
		itemCount: number;
		renderItem: (index: number) => FlowLayoutItem;
		batchCount: number;
		onLoadMore?: () => void;
		loadMore?: boolean;
		loadMoreView?: FlowLayoutItem;
		onScroll?: (offset: {
			x: number;
			y: number;
		}) => void;
		onScrollEnd?: (offset: {
			x: number;
			y: number;
		}) => void;
		scrollable?: boolean;
		/**
		 * Take effect only on iOS
		 */
		bounces?: boolean;
		/**
		* Take effect only on iOS
		*/
		scrollsToTop?: boolean;
		canDrag?: boolean;
		/**
		 * @param from
		 * @returns Returns the item of index which can dragged or not.
		 */
		itemCanDrag?: (from: number) => boolean;
		/**
		 * @param from
		 * @returns Returns an array of index which can not be swap during dragging.
		 */
		beforeDragging?: (from: number) => (Array<number> | void);
		onDragging?: (from: number, to: number) => void;
		onDragged?: (from: number, to: number) => void;
		/**
		 * @param context
		 * @returns Returns array of visible view's index.
		 */
		findVisibleItems(context: BridgeContext): Promise<number[]>;
		/**
		 * @param context
		 * @returns Returns array of completely visible view's index.
		 */
		findCompletelyVisibleItems(context: BridgeContext): Promise<number[]>;
		/**
		 * Reload all list items.
		 * @param context
		 * @returns
		 */
		reload(context: BridgeContext): Promise<void>;
		reset(): void;
		private getItem;
		private renderBunchedItems;
		toModel(): NativeViewModel;
	}
	export function flowlayout(config: Partial<FlowLayout>): FlowLayout;
	export function flowItem(item: View | View[], config?: Partial<FlowLayoutItem>): FlowLayoutItem;
	export enum ReturnKeyType {
		Default = 0,
		Done = 1,
		Search = 2,
		Next = 3,
		Go = 4,
		Send = 5
	}
	export class Input extends View {
		text?: string;
		textColor?: Color;
		textSize?: number;
		font?: string;
		hintText?: string;
		hintFont?: string;
		inputType?: InputType;
		hintTextColor?: Color;
		multiline?: boolean;
		textAlignment?: Gravity;
		fontStyle?: "normal" | "bold" | "italic" | "bold_italic";
		onTextChange?: (text?: string) => void;
		onFocusChange?: (focused: boolean) => void;
		maxLength?: number;
		password?: boolean;
		editable?: boolean;
		returnKeyType?: ReturnKeyType;
		onSubmitEditing?: (text?: string) => void;
		enableHorizontalScrollBar?: boolean;
		enableVerticalScrollBar?: boolean;
		/**
		 * Called before text is changed
		 * @param editing: text already in box
		 * @param replacement: text which will replace part of editing
		 * @param start: the start index of replacing part
		 * @param length: the length of replacing part
		 *
		 * @returns: true means the replacement will take effect, otherwise does not
		 */
		beforeTextChange?: (change: {
			editing?: string;
			start: number;
			length: number;
			replacement?: string;
		}) => boolean;
		padding?: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
		};
		getText(context: BridgeContext): Promise<string>;
		setSelection(context: BridgeContext, start: number, end?: number): Promise<any>;
		getSelection(context: BridgeContext): Promise<{
			start: number;
			end: number;
		}>;
		requestFocus(context: BridgeContext): Promise<any>;
		releaseFocus(context: BridgeContext): Promise<any>;
	}
	export enum InputType {
		Default = 0,
		Number = 1,
		Decimal = 2,
		Alphabet = 3,
		Phone = 4
	}
	export function input(config: Partial<Input>): Input;
	export class NestedSlider extends Group {
		onPageSlided?: (index: number) => void;
		scrollable?: boolean;
		/**
		 * Take effect only on iOS
		 */
		bounces?: boolean;
		/**
		* Take effect only on iOS
		*/
		scrollsToTop?: boolean;
		slidePosition?: number;
		addSlideItem(view: View): void;
		slidePage(context: BridgeContext, page: number, smooth?: boolean): Promise<any>;
		getSlidedPage(context: BridgeContext): Promise<number>;
	}
	/**
	 * @deprecated The class should not be used, please use GestureContainer class instead
	 */
	export class Draggable extends Stack {
		onDrag?: (x: number, y: number) => void;
	}
	/**
	 * @deprecated The function should not be used, please use gestureContainer function instead
	 */
	export function draggable(views: View | View[], config?: Partial<Draggable>): Draggable;
	export class Switch extends View {
		/**
		 * True is on ,false is off,defalut is off.
		 */
		state?: boolean;
		/**
		 * Switch change callback
		 */
		onSwitch?: (state: boolean) => void;
		offTintColor?: Color;
		onTintColor?: Color;
		thumbTintColor?: Color;
	}
	export function switchView(config: Partial<Switch>): Switch;
	export enum SwipeOrientation {
		LEFT = 0,
		RIGHT = 1,
		TOP = 2,
		BOTTOM = 3
	}
	export class GestureContainer extends Stack {
		onSingleTap?: () => void;
		onDoubleTap?: () => void;
		onLongPress?: () => void;
		/**
		 * Called when the fingers in pinching on screen
		 * @param scale: the numeric value of scale on pinch
		 */
		onPinch?: (scale: number) => void;
		/**
		 * Called when the fingers are scrolling or paning
		 * @param dx: the value of the change on the x-axis
		 * @param dy: the value of the change on the y-axis
		 */
		onPan?: (dx: number, dy: number) => void;
		/**
		 * Called when the fingers are scrolling or paning
		 * @param dAngle: the value of the angle change from last rotate in radian
		 */
		onRotate?: (dAngle: number) => void;
		/**
		 * Called when the fingers has swiped on screen
		 * @param orientation: the orientation of this swipe
		 */
		onSwipe?: (orientation: SwipeOrientation) => void;
		/**
		 * Called when the finger touch down on the screen
		 * @param x: the value of event occurs on the x-axis
		 * @param y: the value of event occurs on the y-axis
		 */
		onTouchDown?: (event: {
			x: number;
			y: number;
		}) => void;
		/**
		 * Called when the finger moving on the screen
		 * @param x: the value of event occurs on the x-axis
		 * @param y: the value of event occurs on the y-axis
		 */
		onTouchMove?: (event: {
			x: number;
			y: number;
		}) => void;
		/**
		 * Called when the finger touch up off from the screen
		 * @param x: the value of event occurs on the x-axis
		 * @param y: the value of event occurs on the y-axis
		 */
		onTouchUp?: (event: {
			x: number;
			y: number;
		}) => void;
		/**
		 * Called when the finger leave from screen
		 * @param x: the value of event occurs on the x-axis
		 * @param y: the value of event occurs on the y-axis
		 */
		onTouchCancel?: (event: {
			x: number;
			y: number;
		}) => void;
	}
	export function gestureContainer(views: View | View[], config?: Partial<GestureContainer>): GestureContainer;
	export class BlurEffect extends Stack {
		/**
		 * Specify the effective rectangle.
		 * If not set, the default is the entire area.
		 */
		effectiveRect?: {
			x: number;
			y: number;
			width: number;
			height: number;
		};
		/**
		 * Specify the radius of blur effect.
		 * If not set, the default value is 15.
		 * Suggested value is from 1 to 25.
		 */
		radius?: number;
	}
	export class AeroEffect extends Stack {
		/**
		 * Specify the effective rectangle.
		 * If not set, the default is the entire area.
		 */
		effectiveRect?: {
			x: number;
			y: number;
			width: number;
			height: number;
		};
		/**
		 * Specify the area of the view is lighter or darker than the underlying view.
		 * If not set, the default is light.
		 */
		style?: "light" | "dark" | "extraLight";
	}
	export function blurEffect(views: View | View[], config?: Partial<BlurEffect>): BlurEffect;
	export function aeroEffect(views: View | View[], config?: Partial<AeroEffect>): AeroEffect;
	export class HorizontalListItem extends Stack {
		/**
		 * Set to reuse native view
		 */
		identifier?: string;
	}
	export class HorizontalList extends Superview {
		private cachedViews;
		allSubviews(): HorizontalListItem[];
		itemCount: number;
		renderItem: (index: number) => HorizontalListItem;
		batchCount: number;
		onLoadMore?: () => void;
		loadMore?: boolean;
		loadMoreView?: HorizontalListItem;
		onScroll?: (offset: {
			x: number;
			y: number;
		}) => void;
		onScrollEnd?: (offset: {
			x: number;
			y: number;
		}) => void;
		scrolledPosition?: number;
		scrollable?: boolean;
		/**
		 * Take effect only on iOS
		 */
		bounces?: boolean;
		/**
		* Take effect only on iOS
		*/
		scrollsToTop?: boolean;
		canDrag?: boolean;
		/**
		 * @param from
		 * @returns Returns the item of index which can dragged or not.
		 */
		itemCanDrag?: (from: number) => boolean;
		/**
		 * @param from
		 * @returns Returns an array of index which can not be swap during dragging.
		 */
		beforeDragging?: (from: number) => (Array<number> | void);
		onDragging?: (from: number, to: number) => void;
		onDragged?: (from: number, to: number) => void;
		scrollToItem(context: BridgeContext, index: number, config?: {
			animated?: boolean;
		}): Promise<any>;
		/**
		 * @param context
		 * @returns Returns array of visible view's index.
		 */
		findVisibleItems(context: BridgeContext): Promise<number[]>;
		/**
		 * @param context
		 * @returns Returns array of completely visible view's index.
		 */
		findCompletelyVisibleItems(context: BridgeContext): Promise<number[]>;
		/**
		 * Reload all list items.
		 * @param context
		 * @returns
		 */
		reload(context: BridgeContext): Promise<void>;
		reset(): void;
		private getItem;
		private renderBunchedItems;
		toModel(): NativeViewModel;
	}
	export function horizontalList(config: Partial<HorizontalList>): HorizontalList;
	export function horizontalListItem(item: View | View[], config?: Partial<HorizontalListItem>): HorizontalListItem;
	export function modal(context: BridgeContext): {
		toast: (msg: string, gravity?: Gravity) => void;
		alert: (arg: string | {
			title: string;
			msg: string;
			okLabel?: string;
		}) => Promise<any>;
		confirm: (arg: string | {
			title: string;
			msg: string;
			okLabel?: string;
			cancelLabel?: string;
		}) => Promise<any>;
		prompt: (arg: {
			title?: string;
			msg?: string;
			okLabel?: string;
			cancelLabel?: string;
			text?: string;
			defaultText?: string;
		}) => Promise<string>;
	};
	export function navbar(context: BridgeContext): {
		isHidden: () => Promise<boolean>;
		setHidden: (hidden: boolean) => Promise<any>;
		setTitle: (title: string) => Promise<any>;
		setBgColor: (color: Color) => Promise<any>;
		setLeft: (view: View) => Promise<any>;
		setRight: (view: View) => Promise<any>;
		setCenter: (view: View) => Promise<any>;
	};
	export function internalScheme(context: BridgeContext, panelClass: ClassType<Panel>): string;
	export function navigator(context: BridgeContext): {
		push: (source: string | ClassType<Panel>, config?: {
			alias?: string;
			animated?: boolean;
			extra?: object;
			singlePage?: boolean;
		}) => Promise<any>;
		pop: (animated?: boolean) => Promise<any>;
		popSelf: (animated?: boolean) => Promise<any>;
		popToRoot: (animated?: boolean) => Promise<any>;
		openUrl: (url: string) => Promise<any>;
	};
	export interface IRequest {
		url?: string;
		method?: "get" | "post" | "put" | "delete";
		headers?: {
			[index: string]: string;
		};
		params?: {
			[index: string]: string;
		};
		data?: object | string;
		timeout?: number;
	}
	export interface IResponse {
		data: string;
		status: number;
		headers?: {
			[index: string]: string;
		};
	}
	export function network(context: BridgeContext): {
		request: (config: IRequest) => Promise<IResponse>;
		get: (url: string, config?: IRequest) => Promise<IResponse>;
		post: (url: string, data?: object | string, config?: IRequest) => Promise<IResponse>;
		put: (url: string, data?: object | string, config?: IRequest) => Promise<IResponse>;
		delete: (url: string, data?: object | string, config?: IRequest) => Promise<IResponse>;
	};
	export function storage(context: BridgeContext): {
		setItem: (key: string, value: string, zone?: string) => Promise<any>;
		getItem: (key: string, zone?: string) => Promise<string>;
		remove: (key: string, zone?: string) => Promise<any>;
		clear: (zone: string) => Promise<any>;
	};
	export function popover(context: BridgeContext): {
		show: (view: View) => Promise<any>;
		dismiss: (view?: View | undefined) => Promise<any>;
	};
	/**
	 * Only supports x,y,width,height,corner(just for four corners),rotation,bgColor,
	 * @param panel @see Panel
	 */
	export function animate(context: BridgeContext): (args: {
		animations: () => void;
		duration: number;
	}) => Promise<unknown>;
	export function notification(context: BridgeContext): {
		/**
		 * @param androidSystem: when set true, using global broadcast instead of local broadcast by default
		 * @param iosUsingObject: when set true, using object instead of userInfo by default
		 */
		publish: (args: {
			biz?: string;
			name: string;
			data?: object;
			androidSystem?: boolean;
			iosUsingObject?: boolean;
			permission?: string;
		}) => Promise<any>;
		/**
		 * @param androidSystem: when set true, using global broadcast instead of local broadcast by default
		 * @param iosUsingObject: when set true, using object instead of userInfo by default
		 */
		subscribe: (args: {
			biz?: string | undefined;
			name: string;
			callback: (data?: any) => void;
			androidSystem?: boolean | undefined;
			iosUsingObject?: boolean | undefined;
			permission?: string | undefined;
		}) => Promise<string>;
		unsubscribe: (subscribeId: string) => Promise<any>;
	};
	export enum StatusBarMode {
		LIGHT = 0,
		DARK = 1
	}
	export function statusbar(context: BridgeContext): {
		setHidden: (hidden: boolean) => Promise<any>;
		setMode: (mode: StatusBarMode) => Promise<any>;
		setColor: (color: Color) => Promise<any>;
	};
	export function coordinator(context: BridgeContext): {
		verticalScrolling: (argument: {
			scrollable: Scroller | List | FlowLayout;
			scrollRange: {
				start: number;
				end: number;
			};
			target: View | "NavBar";
			changing: {
				name: "backgroundColor" | "width" | "height" | "x" | "y" | "alpha";
				start: number | Color;
				end: number | Color;
			};
		}) => void;
		observeScrollingInterval: (argument: {
			scrollable: Scroller | List | FlowLayout;
			observingInterval: number[];
			inclusive?: "Left" | "Right" | undefined;
			onScrolledInterval: (n: number) => void;
		}) => void;
	};
	export function notch(context: BridgeContext): {
		inset: () => Promise<{
			top: number;
			left: number;
			bottom: number;
			right: number;
		}>;
	};
	export function keyboard(context: BridgeContext): {
		subscribe: (callback: (data: {
			oldBottomMargin: number;
			oldHeight: number;
			bottomMargin: number;
			height: number;
		}) => void) => Promise<string>;
		unsubscribe: (subscribeId: string) => Promise<any>;
	};
	export function resourceLoader(context: BridgeContext): {
		load: (resource: Resource) => Promise<ArrayBuffer>;
	};
	export function imageDecoder(context: BridgeContext): {
		getImageInfo: (resource: Resource) => Promise<{
			width: number;
			height: number;
			mimeType: string;
		}>;
		decodeToPixels: (resource: Resource) => Promise<ArrayBuffer>;
	};
	export function log(...args: any): void;
	export function loge(...message: any): void;
	export function logw(...message: any): void;
	export function uniqueId(prefix: string): string;
	export namespace jsx {
		function createElement<T extends View>(constructor: ClassType<T>, config: Partial<T> | null, ...children: any[]): any;
		class Fragment extends Group {
		}
	} global {
		namespace JSX {
			interface Element extends View {
			}
			interface ElementClass extends View {
			}
			interface ElementAttributesProperty {
				props: {};
			}
			interface ElementChildrenAttribute {
				innerElement: any;
			}
			interface IntrinsicElements {
			}
		}
	}
	export function take<T>(target: T): (block: (p: T) => void) => void;
	export function takeNonNull<T, R>(target?: T): (block: (p: T) => R) => R | undefined;
	export function takeNull<T, R>(target?: T): (block: () => R) => R | undefined;
	export function takeLet<T, R>(target: T): (block: (p: T) => R | undefined) => R | undefined;
	export function takeAlso<T>(target: T): (block: (p: T) => void) => T;
	export function takeIf<T>(target: T): (predicate: (t: T) => boolean) => T | undefined;
	export function takeUnless<T>(target: T): (predicate: (t: T) => boolean) => T | undefined;
	export function repeat(action: (count: number) => void): (times: number) => void;
	export type Observer<T> = (v: T) => void;
	export type Updater<T> = (v: T) => T;
	export interface IObservable<T> {
		addObserver(observer: Observer<T | undefined>): void;
		removeObserver(observer: Observer<T | undefined>): void;
		update(updater: Updater<T | undefined>): void;
	}
	export class Observable<M> implements IObservable<M> {
		private provider;
		private clz;
		private observers;
		constructor(provider: IProvider, clz: {
			new (...args: any[]): M;
		});
		addObserver(observer: Observer<M | undefined>): void;
		removeObserver(observer: Observer<M | undefined>): void;
		update(updater: Updater<M | undefined>): void;
	}
	export interface IProvider {
		provide(obj: Object): void;
		acquire<T>(clz: {
			new (...args: any[]): T;
		}): T | undefined;
		remove<T>(clz: {
			new (...args: any[]): T;
		}): void;
		clear(): void;
		observe<T>(clz: {
			new (...args: any[]): T;
		}): Observable<T>;
	}
	export class Provider implements IProvider {
		private provision;
		private observableMap;
		provide(obj: Object): void;
		acquire<T>(clz: {
			new (...args: any[]): T;
		}): T | undefined;
		remove<T>(clz: new (...args: any[]) => T): void;
		clear(): void;
		observe<T>(clz: new (...args: any[]) => T): Observable<T>;
	}
	export abstract class ViewHolder {
		abstract build(root: Group): void;
	}
	export type Setter<M> = (state: M) => void;
	export abstract class ViewModel<M extends Object, V extends ViewHolder> {
		context: BridgeContext;
		private state;
		private viewHolder;
		constructor(obj: M, v: V);
		getState(): M;
		getViewHolder(): V;
		updateState(setter: Setter<M>): void;
		attach(view: Group): void;
		abstract onAttached(state: M, vh: V): void;
		abstract onBind(state: M, vh: V): void;
	}
	export abstract class VMPanel<M extends Object, V extends ViewHolder> extends Panel {
		private vm?;
		private vh?;
		abstract getViewModelClass(): ClassType<ViewModel<M, V>>;
		abstract getState(): M;
		abstract getViewHolderClass(): ClassType<V>;
		getViewModel(): ViewModel<M, V> | undefined;
		build(root: Group): void;
	}
	export abstract class Module extends Panel {
		superPanel?: ModularPanel;
		__provider?: Provider;
		get provider(): Provider | undefined;
		set provider(provider: Provider | undefined);
		private unmounted;
		mount(): void;
		unmount(): void;
		get mounted(): boolean;
		/**
		 * Dispatch message to other modules.
		 * @param message which is sent out
		 */
		dispatchMessage(message: any): void;
		/**
		 * Dispatched messages can be received by override this method.
		 * @param message recevied message
		 */
		onMessage(message: any): void;
		/**
		 * Called when this module is mounted
		 */
		onMounted(): void;
		/**
		 * Called when this module is unmounted
		 */
		onUnmounted(): void;
	}
	export abstract class VMModule<M extends Object, V extends ViewHolder> extends Module {
		private vm?;
		private vh?;
		abstract getViewModelClass(): ClassType<ViewModel<M, V>>;
		abstract getState(): M;
		abstract getViewHolderClass(): ClassType<V>;
		getViewModel(): ViewModel<M, V> | undefined;
		build(root: Group): void;
	}
	export abstract class ModularPanel extends Module {
		private modules;
		private scheduledRebuild?;
		constructor();
		/**
		 * @returns Class list of current submodules
		 */
		abstract setupModules(): ClassType<Panel>[];
		/**
		 * @param root Current module's rootview
		 * @returns provided for submodules as their rootview
		 */
		abstract setupShelf(root: Group): Group;
		dispatchMessage(message: any): void;
		get mountedModules(): Panel[];
		onMessage(message: any): void;
		onStructureChanged(module: Module, mounted: boolean): void;
		build(root: Group): void;
		onCreate(): void;
		onDestroy(): void;
		onShow(): void;
		onHidden(): void;
		onRenderFinished(): void;
	} global {
		namespace Reflect {
			function decorate(decorators: ClassDecorator[], target: Function): Function;
			function decorate(decorators: (PropertyDecorator | MethodDecorator)[], target: Object, propertyKey: string | symbol, attributes?: PropertyDescriptor): PropertyDescriptor;
			function metadata(metadataKey: any, metadataValue: any): {
				(target: Function): void;
				(target: Object, propertyKey: string | symbol): void;
			};
			function defineMetadata(metadataKey: any, metadataValue: any, target: Object): void;
			function defineMetadata(metadataKey: any, metadataValue: any, target: Object, propertyKey: string | symbol): void;
			function hasMetadata(metadataKey: any, target: Object): boolean;
			function hasMetadata(metadataKey: any, target: Object, propertyKey: string | symbol): boolean;
			function hasOwnMetadata(metadataKey: any, target: Object): boolean;
			function hasOwnMetadata(metadataKey: any, target: Object, propertyKey: string | symbol): boolean;
			function getMetadata(metadataKey: any, target: Object): any;
			function getMetadata(metadataKey: any, target: Object, propertyKey: string | symbol): any;
			function getOwnMetadata(metadataKey: any, target: Object): any;
			function getOwnMetadata(metadataKey: any, target: Object, propertyKey: string | symbol): any;
			function getMetadataKeys(target: Object): any[];
			function getMetadataKeys(target: Object, propertyKey: string | symbol): any[];
			function getOwnMetadataKeys(target: Object): any[];
			function getOwnMetadataKeys(target: Object, propertyKey: string | symbol): any[];
			function deleteMetadata(metadataKey: any, target: Object): boolean;
			function deleteMetadata(metadataKey: any, target: Object, propertyKey: string | symbol): boolean;
		}
	}
	
	export {};
	
}
declare module '*.png' {
    const value: any;
    export default value;
}
  